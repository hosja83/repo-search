{"ast":null,"code":"/**\n  * This file contains the Bottleneck library (MIT), compiled to ES2017, and without Clustering support.\n  * https://github.com/SGrondin/bottleneck\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Bottleneck = factory();\n})(this, function () {\n  'use strict';\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function getCjsExportFromNamespace(n) {\n    return n && n['default'] || n;\n  }\n\n  var load = function (received, defaults) {\n    let onto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var k, ref, v;\n\n    for (k in defaults) {\n      v = defaults[k];\n      onto[k] = (ref = received[k]) != null ? ref : v;\n    }\n\n    return onto;\n  };\n\n  var overwrite = function (received, defaults) {\n    let onto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var k, v;\n\n    for (k in received) {\n      v = received[k];\n\n      if (defaults[k] !== void 0) {\n        onto[k] = v;\n      }\n    }\n\n    return onto;\n  };\n\n  var parser = {\n    load: load,\n    overwrite: overwrite\n  };\n  var DLList;\n  DLList = class DLList {\n    constructor(incr, decr) {\n      this.incr = incr;\n      this.decr = decr;\n      this._first = null;\n      this._last = null;\n      this.length = 0;\n    }\n\n    push(value) {\n      var node;\n      this.length++;\n\n      if (typeof this.incr === \"function\") {\n        this.incr();\n      }\n\n      node = {\n        value,\n        prev: this._last,\n        next: null\n      };\n\n      if (this._last != null) {\n        this._last.next = node;\n        this._last = node;\n      } else {\n        this._first = this._last = node;\n      }\n\n      return void 0;\n    }\n\n    shift() {\n      var value;\n\n      if (this._first == null) {\n        return;\n      } else {\n        this.length--;\n\n        if (typeof this.decr === \"function\") {\n          this.decr();\n        }\n      }\n\n      value = this._first.value;\n\n      if ((this._first = this._first.next) != null) {\n        this._first.prev = null;\n      } else {\n        this._last = null;\n      }\n\n      return value;\n    }\n\n    first() {\n      if (this._first != null) {\n        return this._first.value;\n      }\n    }\n\n    getArray() {\n      var node, ref, results;\n      node = this._first;\n      results = [];\n\n      while (node != null) {\n        results.push((ref = node, node = node.next, ref.value));\n      }\n\n      return results;\n    }\n\n    forEachShift(cb) {\n      var node;\n      node = this.shift();\n\n      while (node != null) {\n        cb(node), node = this.shift();\n      }\n\n      return void 0;\n    }\n\n    debug() {\n      var node, ref, ref1, ref2, results;\n      node = this._first;\n      results = [];\n\n      while (node != null) {\n        results.push((ref = node, node = node.next, {\n          value: ref.value,\n          prev: (ref1 = ref.prev) != null ? ref1.value : void 0,\n          next: (ref2 = ref.next) != null ? ref2.value : void 0\n        }));\n      }\n\n      return results;\n    }\n\n  };\n  var DLList_1 = DLList;\n  var Events;\n  Events = class Events {\n    constructor(instance) {\n      var _this = this;\n\n      this.instance = instance;\n      this._events = {};\n\n      if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {\n        throw new Error(\"An Emitter already exists for this object\");\n      }\n\n      this.instance.on = (name, cb) => {\n        return this._addListener(name, \"many\", cb);\n      };\n\n      this.instance.once = (name, cb) => {\n        return this._addListener(name, \"once\", cb);\n      };\n\n      this.instance.removeAllListeners = function () {\n        let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        if (name != null) {\n          return delete _this._events[name];\n        } else {\n          return _this._events = {};\n        }\n      };\n    }\n\n    _addListener(name, status, cb) {\n      var base;\n\n      if ((base = this._events)[name] == null) {\n        base[name] = [];\n      }\n\n      this._events[name].push({\n        cb,\n        status\n      });\n\n      return this.instance;\n    }\n\n    listenerCount(name) {\n      if (this._events[name] != null) {\n        return this._events[name].length;\n      } else {\n        return 0;\n      }\n    }\n\n    async trigger(name) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var e, promises;\n\n      try {\n        if (name !== \"debug\") {\n          this.trigger(\"debug\", `Event triggered: ${name}`, args);\n        }\n\n        if (this._events[name] == null) {\n          return;\n        }\n\n        this._events[name] = this._events[name].filter(function (listener) {\n          return listener.status !== \"none\";\n        });\n        promises = this._events[name].map(async listener => {\n          var e, returned;\n\n          if (listener.status === \"none\") {\n            return;\n          }\n\n          if (listener.status === \"once\") {\n            listener.status = \"none\";\n          }\n\n          try {\n            returned = typeof listener.cb === \"function\" ? listener.cb(...args) : void 0;\n\n            if (typeof (returned != null ? returned.then : void 0) === \"function\") {\n              return await returned;\n            } else {\n              return returned;\n            }\n          } catch (error) {\n            e = error;\n            {\n              this.trigger(\"error\", e);\n            }\n            return null;\n          }\n        });\n        return (await Promise.all(promises)).find(function (x) {\n          return x != null;\n        });\n      } catch (error) {\n        e = error;\n        {\n          this.trigger(\"error\", e);\n        }\n        return null;\n      }\n    }\n\n  };\n  var Events_1 = Events;\n  var DLList$1, Events$1, Queues;\n  DLList$1 = DLList_1;\n  Events$1 = Events_1;\n  Queues = class Queues {\n    constructor(num_priorities) {\n      var i;\n      this.Events = new Events$1(this);\n      this._length = 0;\n\n      this._lists = function () {\n        var j, ref, results;\n        results = [];\n\n        for (i = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n          results.push(new DLList$1(() => {\n            return this.incr();\n          }, () => {\n            return this.decr();\n          }));\n        }\n\n        return results;\n      }.call(this);\n    }\n\n    incr() {\n      if (this._length++ === 0) {\n        return this.Events.trigger(\"leftzero\");\n      }\n    }\n\n    decr() {\n      if (--this._length === 0) {\n        return this.Events.trigger(\"zero\");\n      }\n    }\n\n    push(job) {\n      return this._lists[job.options.priority].push(job);\n    }\n\n    queued(priority) {\n      if (priority != null) {\n        return this._lists[priority].length;\n      } else {\n        return this._length;\n      }\n    }\n\n    shiftAll(fn) {\n      return this._lists.forEach(function (list) {\n        return list.forEachShift(fn);\n      });\n    }\n\n    getFirst() {\n      let arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._lists;\n      var j, len, list;\n\n      for (j = 0, len = arr.length; j < len; j++) {\n        list = arr[j];\n\n        if (list.length > 0) {\n          return list;\n        }\n      }\n\n      return [];\n    }\n\n    shiftLastFrom(priority) {\n      return this.getFirst(this._lists.slice(priority).reverse()).shift();\n    }\n\n  };\n  var Queues_1 = Queues;\n  var BottleneckError;\n  BottleneckError = class BottleneckError extends Error {};\n  var BottleneckError_1 = BottleneckError;\n  var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;\n  NUM_PRIORITIES = 10;\n  DEFAULT_PRIORITY = 5;\n  parser$1 = parser;\n  BottleneckError$1 = BottleneckError_1;\n  Job = class Job {\n    constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise) {\n      this.task = task;\n      this.args = args;\n      this.rejectOnDrop = rejectOnDrop;\n      this.Events = Events;\n      this._states = _states;\n      this.Promise = Promise;\n      this.options = parser$1.load(options, jobDefaults);\n      this.options.priority = this._sanitizePriority(this.options.priority);\n\n      if (this.options.id === jobDefaults.id) {\n        this.options.id = `${this.options.id}-${this._randomIndex()}`;\n      }\n\n      this.promise = new this.Promise((_resolve, _reject) => {\n        this._resolve = _resolve;\n        this._reject = _reject;\n      });\n      this.retryCount = 0;\n    }\n\n    _sanitizePriority(priority) {\n      var sProperty;\n      sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;\n\n      if (sProperty < 0) {\n        return 0;\n      } else if (sProperty > NUM_PRIORITIES - 1) {\n        return NUM_PRIORITIES - 1;\n      } else {\n        return sProperty;\n      }\n    }\n\n    _randomIndex() {\n      return Math.random().toString(36).slice(2);\n    }\n\n    doDrop() {\n      let {\n        error,\n        message = \"This job has been dropped by Bottleneck\"\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._states.remove(this.options.id)) {\n        if (this.rejectOnDrop) {\n          this._reject(error != null ? error : new BottleneckError$1(message));\n        }\n\n        this.Events.trigger(\"dropped\", {\n          args: this.args,\n          options: this.options,\n          task: this.task,\n          promise: this.promise\n        });\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    _assertStatus(expected) {\n      var status;\n      status = this._states.jobStatus(this.options.id);\n\n      if (!(status === expected || expected === \"DONE\" && status === null)) {\n        throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);\n      }\n    }\n\n    doReceive() {\n      this._states.start(this.options.id);\n\n      return this.Events.trigger(\"received\", {\n        args: this.args,\n        options: this.options\n      });\n    }\n\n    doQueue(reachedHWM, blocked) {\n      this._assertStatus(\"RECEIVED\");\n\n      this._states.next(this.options.id);\n\n      return this.Events.trigger(\"queued\", {\n        args: this.args,\n        options: this.options,\n        reachedHWM,\n        blocked\n      });\n    }\n\n    doRun() {\n      if (this.retryCount === 0) {\n        this._assertStatus(\"QUEUED\");\n\n        this._states.next(this.options.id);\n      } else {\n        this._assertStatus(\"EXECUTING\");\n      }\n\n      return this.Events.trigger(\"scheduled\", {\n        args: this.args,\n        options: this.options\n      });\n    }\n\n    async doExecute(chained, clearGlobalState, run, free) {\n      var error, eventInfo, passed;\n\n      if (this.retryCount === 0) {\n        this._assertStatus(\"RUNNING\");\n\n        this._states.next(this.options.id);\n      } else {\n        this._assertStatus(\"EXECUTING\");\n      }\n\n      eventInfo = {\n        args: this.args,\n        options: this.options,\n        retryCount: this.retryCount\n      };\n      this.Events.trigger(\"executing\", eventInfo);\n\n      try {\n        passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));\n\n        if (clearGlobalState()) {\n          this.doDone(eventInfo);\n          await free(this.options, eventInfo);\n\n          this._assertStatus(\"DONE\");\n\n          return this._resolve(passed);\n        }\n      } catch (error1) {\n        error = error1;\n        return this._onFailure(error, eventInfo, clearGlobalState, run, free);\n      }\n    }\n\n    doExpire(clearGlobalState, run, free) {\n      var error, eventInfo;\n\n      if (this._states.jobStatus(this.options.id === \"RUNNING\")) {\n        this._states.next(this.options.id);\n      }\n\n      this._assertStatus(\"EXECUTING\");\n\n      eventInfo = {\n        args: this.args,\n        options: this.options,\n        retryCount: this.retryCount\n      };\n      error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);\n      return this._onFailure(error, eventInfo, clearGlobalState, run, free);\n    }\n\n    async _onFailure(error, eventInfo, clearGlobalState, run, free) {\n      var retry, retryAfter;\n\n      if (clearGlobalState()) {\n        retry = await this.Events.trigger(\"failed\", error, eventInfo);\n\n        if (retry != null) {\n          retryAfter = ~~retry;\n          this.Events.trigger(\"retry\", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);\n          this.retryCount++;\n          return run(retryAfter);\n        } else {\n          this.doDone(eventInfo);\n          await free(this.options, eventInfo);\n\n          this._assertStatus(\"DONE\");\n\n          return this._reject(error);\n        }\n      }\n    }\n\n    doDone(eventInfo) {\n      this._assertStatus(\"EXECUTING\");\n\n      this._states.next(this.options.id);\n\n      return this.Events.trigger(\"done\", eventInfo);\n    }\n\n  };\n  var Job_1 = Job;\n  var BottleneckError$2, LocalDatastore, parser$2;\n  parser$2 = parser;\n  BottleneckError$2 = BottleneckError_1;\n  LocalDatastore = class LocalDatastore {\n    constructor(instance, storeOptions, storeInstanceOptions) {\n      this.instance = instance;\n      this.storeOptions = storeOptions;\n      this.clientId = this.instance._randomIndex();\n      parser$2.load(storeInstanceOptions, storeInstanceOptions, this);\n      this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n      this._running = 0;\n      this._done = 0;\n      this._unblockTime = 0;\n      this.ready = this.Promise.resolve();\n      this.clients = {};\n\n      this._startHeartbeat();\n    }\n\n    _startHeartbeat() {\n      var base;\n\n      if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {\n        return typeof (base = this.heartbeat = setInterval(() => {\n          var amount, incr, maximum, now, reservoir;\n          now = Date.now();\n\n          if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\n            this._lastReservoirRefresh = now;\n            this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\n\n            this.instance._drainAll(this.computeCapacity());\n          }\n\n          if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\n            ({\n              reservoirIncreaseAmount: amount,\n              reservoirIncreaseMaximum: maximum,\n              reservoir\n            } = this.storeOptions);\n            this._lastReservoirIncrease = now;\n            incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n\n            if (incr > 0) {\n              this.storeOptions.reservoir += incr;\n              return this.instance._drainAll(this.computeCapacity());\n            }\n          }\n        }, this.heartbeatInterval)).unref === \"function\" ? base.unref() : void 0;\n      } else {\n        return clearInterval(this.heartbeat);\n      }\n    }\n\n    async __publish__(message) {\n      await this.yieldLoop();\n      return this.instance.Events.trigger(\"message\", message.toString());\n    }\n\n    async __disconnect__(flush) {\n      await this.yieldLoop();\n      clearInterval(this.heartbeat);\n      return this.Promise.resolve();\n    }\n\n    yieldLoop() {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return new this.Promise(function (resolve, reject) {\n        return setTimeout(resolve, t);\n      });\n    }\n\n    computePenalty() {\n      var ref;\n      return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;\n    }\n\n    async __updateSettings__(options) {\n      await this.yieldLoop();\n      parser$2.overwrite(options, options, this.storeOptions);\n\n      this._startHeartbeat();\n\n      this.instance._drainAll(this.computeCapacity());\n\n      return true;\n    }\n\n    async __running__() {\n      await this.yieldLoop();\n      return this._running;\n    }\n\n    async __queued__() {\n      await this.yieldLoop();\n      return this.instance.queued();\n    }\n\n    async __done__() {\n      await this.yieldLoop();\n      return this._done;\n    }\n\n    async __groupCheck__(time) {\n      await this.yieldLoop();\n      return this._nextRequest + this.timeout < time;\n    }\n\n    computeCapacity() {\n      var maxConcurrent, reservoir;\n      ({\n        maxConcurrent,\n        reservoir\n      } = this.storeOptions);\n\n      if (maxConcurrent != null && reservoir != null) {\n        return Math.min(maxConcurrent - this._running, reservoir);\n      } else if (maxConcurrent != null) {\n        return maxConcurrent - this._running;\n      } else if (reservoir != null) {\n        return reservoir;\n      } else {\n        return null;\n      }\n    }\n\n    conditionsCheck(weight) {\n      var capacity;\n      capacity = this.computeCapacity();\n      return capacity == null || weight <= capacity;\n    }\n\n    async __incrementReservoir__(incr) {\n      var reservoir;\n      await this.yieldLoop();\n      reservoir = this.storeOptions.reservoir += incr;\n\n      this.instance._drainAll(this.computeCapacity());\n\n      return reservoir;\n    }\n\n    async __currentReservoir__() {\n      await this.yieldLoop();\n      return this.storeOptions.reservoir;\n    }\n\n    isBlocked(now) {\n      return this._unblockTime >= now;\n    }\n\n    check(weight, now) {\n      return this.conditionsCheck(weight) && this._nextRequest - now <= 0;\n    }\n\n    async __check__(weight) {\n      var now;\n      await this.yieldLoop();\n      now = Date.now();\n      return this.check(weight, now);\n    }\n\n    async __register__(index, weight, expiration) {\n      var now, wait;\n      await this.yieldLoop();\n      now = Date.now();\n\n      if (this.conditionsCheck(weight)) {\n        this._running += weight;\n\n        if (this.storeOptions.reservoir != null) {\n          this.storeOptions.reservoir -= weight;\n        }\n\n        wait = Math.max(this._nextRequest - now, 0);\n        this._nextRequest = now + wait + this.storeOptions.minTime;\n        return {\n          success: true,\n          wait,\n          reservoir: this.storeOptions.reservoir\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    }\n\n    strategyIsBlock() {\n      return this.storeOptions.strategy === 3;\n    }\n\n    async __submit__(queueLength, weight) {\n      var blocked, now, reachedHWM;\n      await this.yieldLoop();\n\n      if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) {\n        throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);\n      }\n\n      now = Date.now();\n      reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);\n      blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));\n\n      if (blocked) {\n        this._unblockTime = now + this.computePenalty();\n        this._nextRequest = this._unblockTime + this.storeOptions.minTime;\n\n        this.instance._dropAllQueued();\n      }\n\n      return {\n        reachedHWM,\n        blocked,\n        strategy: this.storeOptions.strategy\n      };\n    }\n\n    async __free__(index, weight) {\n      await this.yieldLoop();\n      this._running -= weight;\n      this._done += weight;\n\n      this.instance._drainAll(this.computeCapacity());\n\n      return {\n        running: this._running\n      };\n    }\n\n  };\n  var LocalDatastore_1 = LocalDatastore;\n  var BottleneckError$3, States;\n  BottleneckError$3 = BottleneckError_1;\n  States = class States {\n    constructor(status1) {\n      this.status = status1;\n      this._jobs = {};\n      this.counts = this.status.map(function () {\n        return 0;\n      });\n    }\n\n    next(id) {\n      var current, next;\n      current = this._jobs[id];\n      next = current + 1;\n\n      if (current != null && next < this.status.length) {\n        this.counts[current]--;\n        this.counts[next]++;\n        return this._jobs[id]++;\n      } else if (current != null) {\n        this.counts[current]--;\n        return delete this._jobs[id];\n      }\n    }\n\n    start(id) {\n      var initial;\n      initial = 0;\n      this._jobs[id] = initial;\n      return this.counts[initial]++;\n    }\n\n    remove(id) {\n      var current;\n      current = this._jobs[id];\n\n      if (current != null) {\n        this.counts[current]--;\n        delete this._jobs[id];\n      }\n\n      return current != null;\n    }\n\n    jobStatus(id) {\n      var ref;\n      return (ref = this.status[this._jobs[id]]) != null ? ref : null;\n    }\n\n    statusJobs(status) {\n      var k, pos, ref, results, v;\n\n      if (status != null) {\n        pos = this.status.indexOf(status);\n\n        if (pos < 0) {\n          throw new BottleneckError$3(`status must be one of ${this.status.join(', ')}`);\n        }\n\n        ref = this._jobs;\n        results = [];\n\n        for (k in ref) {\n          v = ref[k];\n\n          if (v === pos) {\n            results.push(k);\n          }\n        }\n\n        return results;\n      } else {\n        return Object.keys(this._jobs);\n      }\n    }\n\n    statusCounts() {\n      return this.counts.reduce((acc, v, i) => {\n        acc[this.status[i]] = v;\n        return acc;\n      }, {});\n    }\n\n  };\n  var States_1 = States;\n  var DLList$2, Sync;\n  DLList$2 = DLList_1;\n  Sync = class Sync {\n    constructor(name, Promise) {\n      this.schedule = this.schedule.bind(this);\n      this.name = name;\n      this.Promise = Promise;\n      this._running = 0;\n      this._queue = new DLList$2();\n    }\n\n    isEmpty() {\n      return this._queue.length === 0;\n    }\n\n    async _tryToRun() {\n      var args, cb, error, reject, resolve, returned, task;\n\n      if (this._running < 1 && this._queue.length > 0) {\n        this._running++;\n        ({\n          task,\n          args,\n          resolve,\n          reject\n        } = this._queue.shift());\n        cb = await async function () {\n          try {\n            returned = await task(...args);\n            return function () {\n              return resolve(returned);\n            };\n          } catch (error1) {\n            error = error1;\n            return function () {\n              return reject(error);\n            };\n          }\n        }();\n        this._running--;\n\n        this._tryToRun();\n\n        return cb();\n      }\n    }\n\n    schedule(task) {\n      var promise, reject, resolve;\n      resolve = reject = null;\n      promise = new this.Promise(function (_resolve, _reject) {\n        resolve = _resolve;\n        return reject = _reject;\n      });\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this._queue.push({\n        task,\n        args,\n        resolve,\n        reject\n      });\n\n      this._tryToRun();\n\n      return promise;\n    }\n\n  };\n  var Sync_1 = Sync;\n  var version = \"2.19.5\";\n  var version$1 = {\n    version: version\n  };\n  var version$2 = /*#__PURE__*/Object.freeze({\n    version: version,\n    default: version$1\n  });\n\n  var require$$2 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n  var require$$3 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n  var require$$4 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n  var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;\n  parser$3 = parser;\n  Events$2 = Events_1;\n  RedisConnection$1 = require$$2;\n  IORedisConnection$1 = require$$3;\n  Scripts$1 = require$$4;\n\n  Group = function () {\n    class Group {\n      constructor() {\n        let limiterOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.deleteKey = this.deleteKey.bind(this);\n        this.limiterOptions = limiterOptions;\n        parser$3.load(this.limiterOptions, this.defaults, this);\n        this.Events = new Events$2(this);\n        this.instances = {};\n        this.Bottleneck = Bottleneck_1;\n\n        this._startAutoCleanup();\n\n        this.sharedConnection = this.connection != null;\n\n        if (this.connection == null) {\n          if (this.limiterOptions.datastore === \"redis\") {\n            this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, {\n              Events: this.Events\n            }));\n          } else if (this.limiterOptions.datastore === \"ioredis\") {\n            this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, {\n              Events: this.Events\n            }));\n          }\n        }\n      }\n\n      key() {\n        let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        var ref;\n        return (ref = this.instances[key]) != null ? ref : (() => {\n          var limiter;\n          limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {\n            id: `${this.id}-${key}`,\n            timeout: this.timeout,\n            connection: this.connection\n          }));\n          this.Events.trigger(\"created\", limiter, key);\n          return limiter;\n        })();\n      }\n\n      async deleteKey() {\n        let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        var deleted, instance;\n        instance = this.instances[key];\n\n        if (this.connection) {\n          deleted = await this.connection.__runCommand__(['del', ...Scripts$1.allKeys(`${this.id}-${key}`)]);\n        }\n\n        if (instance != null) {\n          delete this.instances[key];\n          await instance.disconnect();\n        }\n\n        return instance != null || deleted > 0;\n      }\n\n      limiters() {\n        var k, ref, results, v;\n        ref = this.instances;\n        results = [];\n\n        for (k in ref) {\n          v = ref[k];\n          results.push({\n            key: k,\n            limiter: v\n          });\n        }\n\n        return results;\n      }\n\n      keys() {\n        return Object.keys(this.instances);\n      }\n\n      async clusterKeys() {\n        var cursor, end, found, i, k, keys, len, next, start;\n\n        if (this.connection == null) {\n          return this.Promise.resolve(this.keys());\n        }\n\n        keys = [];\n        cursor = null;\n        start = `b_${this.id}-`.length;\n        end = \"_settings\".length;\n\n        while (cursor !== 0) {\n          [next, found] = await this.connection.__runCommand__([\"scan\", cursor != null ? cursor : 0, \"match\", `b_${this.id}-*_settings`, \"count\", 10000]);\n          cursor = ~~next;\n\n          for (i = 0, len = found.length; i < len; i++) {\n            k = found[i];\n            keys.push(k.slice(start, -end));\n          }\n        }\n\n        return keys;\n      }\n\n      _startAutoCleanup() {\n        var base;\n        clearInterval(this.interval);\n        return typeof (base = this.interval = setInterval(async () => {\n          var e, k, ref, results, time, v;\n          time = Date.now();\n          ref = this.instances;\n          results = [];\n\n          for (k in ref) {\n            v = ref[k];\n\n            try {\n              if (await v._store.__groupCheck__(time)) {\n                results.push(this.deleteKey(k));\n              } else {\n                results.push(void 0);\n              }\n            } catch (error) {\n              e = error;\n              results.push(v.Events.trigger(\"error\", e));\n            }\n          }\n\n          return results;\n        }, this.timeout / 2)).unref === \"function\" ? base.unref() : void 0;\n      }\n\n      updateSettings() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        parser$3.overwrite(options, this.defaults, this);\n        parser$3.overwrite(options, options, this.limiterOptions);\n\n        if (options.timeout != null) {\n          return this._startAutoCleanup();\n        }\n      }\n\n      disconnect() {\n        let flush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var ref;\n\n        if (!this.sharedConnection) {\n          return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;\n        }\n      }\n\n    }\n\n    Group.prototype.defaults = {\n      timeout: 1000 * 60 * 5,\n      connection: null,\n      Promise: Promise,\n      id: \"group-key\"\n    };\n    return Group;\n  }.call(commonjsGlobal);\n\n  var Group_1 = Group;\n  var Batcher, Events$3, parser$4;\n  parser$4 = parser;\n  Events$3 = Events_1;\n\n  Batcher = function () {\n    class Batcher {\n      constructor() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.options = options;\n        parser$4.load(this.options, this.defaults, this);\n        this.Events = new Events$3(this);\n        this._arr = [];\n\n        this._resetPromise();\n\n        this._lastFlush = Date.now();\n      }\n\n      _resetPromise() {\n        return this._promise = new this.Promise((res, rej) => {\n          return this._resolve = res;\n        });\n      }\n\n      _flush() {\n        clearTimeout(this._timeout);\n        this._lastFlush = Date.now();\n\n        this._resolve();\n\n        this.Events.trigger(\"batch\", this._arr);\n        this._arr = [];\n        return this._resetPromise();\n      }\n\n      add(data) {\n        var ret;\n\n        this._arr.push(data);\n\n        ret = this._promise;\n\n        if (this._arr.length === this.maxSize) {\n          this._flush();\n        } else if (this.maxTime != null && this._arr.length === 1) {\n          this._timeout = setTimeout(() => {\n            return this._flush();\n          }, this.maxTime);\n        }\n\n        return ret;\n      }\n\n    }\n\n    Batcher.prototype.defaults = {\n      maxTime: null,\n      maxSize: null,\n      Promise: Promise\n    };\n    return Batcher;\n  }.call(commonjsGlobal);\n\n  var Batcher_1 = Batcher;\n\n  var require$$4$1 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n  var require$$8 = getCjsExportFromNamespace(version$2);\n  var Bottleneck,\n      DEFAULT_PRIORITY$1,\n      Events$4,\n      Job$1,\n      LocalDatastore$1,\n      NUM_PRIORITIES$1,\n      Queues$1,\n      RedisDatastore$1,\n      States$1,\n      Sync$1,\n      parser$5,\n      splice = [].splice;\n  NUM_PRIORITIES$1 = 10;\n  DEFAULT_PRIORITY$1 = 5;\n  parser$5 = parser;\n  Queues$1 = Queues_1;\n  Job$1 = Job_1;\n  LocalDatastore$1 = LocalDatastore_1;\n  RedisDatastore$1 = require$$4$1;\n  Events$4 = Events_1;\n  States$1 = States_1;\n  Sync$1 = Sync_1;\n\n  Bottleneck = function () {\n    class Bottleneck {\n      constructor() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var storeInstanceOptions, storeOptions;\n        this._addToQueue = this._addToQueue.bind(this);\n\n        for (var _len3 = arguments.length, invalid = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          invalid[_key3 - 1] = arguments[_key3];\n        }\n\n        this._validateOptions(options, invalid);\n\n        parser$5.load(options, this.instanceDefaults, this);\n        this._queues = new Queues$1(NUM_PRIORITIES$1);\n        this._scheduled = {};\n        this._states = new States$1([\"RECEIVED\", \"QUEUED\", \"RUNNING\", \"EXECUTING\"].concat(this.trackDoneStatus ? [\"DONE\"] : []));\n        this._limiter = null;\n        this.Events = new Events$4(this);\n        this._submitLock = new Sync$1(\"submit\", this.Promise);\n        this._registerLock = new Sync$1(\"register\", this.Promise);\n        storeOptions = parser$5.load(options, this.storeDefaults, {});\n\n        this._store = function () {\n          if (this.datastore === \"redis\" || this.datastore === \"ioredis\" || this.connection != null) {\n            storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});\n            return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);\n          } else if (this.datastore === \"local\") {\n            storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});\n            return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);\n          } else {\n            throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);\n          }\n        }.call(this);\n\n        this._queues.on(\"leftzero\", () => {\n          var ref;\n          return (ref = this._store.heartbeat) != null ? typeof ref.ref === \"function\" ? ref.ref() : void 0 : void 0;\n        });\n\n        this._queues.on(\"zero\", () => {\n          var ref;\n          return (ref = this._store.heartbeat) != null ? typeof ref.unref === \"function\" ? ref.unref() : void 0 : void 0;\n        });\n      }\n\n      _validateOptions(options, invalid) {\n        if (!(options != null && typeof options === \"object\" && invalid.length === 0)) {\n          throw new Bottleneck.prototype.BottleneckError(\"Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.\");\n        }\n      }\n\n      ready() {\n        return this._store.ready;\n      }\n\n      clients() {\n        return this._store.clients;\n      }\n\n      channel() {\n        return `b_${this.id}`;\n      }\n\n      channel_client() {\n        return `b_${this.id}_${this._store.clientId}`;\n      }\n\n      publish(message) {\n        return this._store.__publish__(message);\n      }\n\n      disconnect() {\n        let flush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        return this._store.__disconnect__(flush);\n      }\n\n      chain(_limiter) {\n        this._limiter = _limiter;\n        return this;\n      }\n\n      queued(priority) {\n        return this._queues.queued(priority);\n      }\n\n      clusterQueued() {\n        return this._store.__queued__();\n      }\n\n      empty() {\n        return this.queued() === 0 && this._submitLock.isEmpty();\n      }\n\n      running() {\n        return this._store.__running__();\n      }\n\n      done() {\n        return this._store.__done__();\n      }\n\n      jobStatus(id) {\n        return this._states.jobStatus(id);\n      }\n\n      jobs(status) {\n        return this._states.statusJobs(status);\n      }\n\n      counts() {\n        return this._states.statusCounts();\n      }\n\n      _randomIndex() {\n        return Math.random().toString(36).slice(2);\n      }\n\n      check() {\n        let weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        return this._store.__check__(weight);\n      }\n\n      _clearGlobalState(index) {\n        if (this._scheduled[index] != null) {\n          clearTimeout(this._scheduled[index].expiration);\n          delete this._scheduled[index];\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      async _free(index, job, options, eventInfo) {\n        var e, running;\n\n        try {\n          ({\n            running\n          } = await this._store.__free__(index, options.weight));\n          this.Events.trigger(\"debug\", `Freed ${options.id}`, eventInfo);\n\n          if (running === 0 && this.empty()) {\n            return this.Events.trigger(\"idle\");\n          }\n        } catch (error1) {\n          e = error1;\n          return this.Events.trigger(\"error\", e);\n        }\n      }\n\n      _run(index, job, wait) {\n        var clearGlobalState, free, run;\n        job.doRun();\n        clearGlobalState = this._clearGlobalState.bind(this, index);\n        run = this._run.bind(this, index, job);\n        free = this._free.bind(this, index, job);\n        return this._scheduled[index] = {\n          timeout: setTimeout(() => {\n            return job.doExecute(this._limiter, clearGlobalState, run, free);\n          }, wait),\n          expiration: job.options.expiration != null ? setTimeout(function () {\n            return job.doExpire(clearGlobalState, run, free);\n          }, wait + job.options.expiration) : void 0,\n          job: job\n        };\n      }\n\n      _drainOne(capacity) {\n        return this._registerLock.schedule(() => {\n          var args, index, next, options, queue;\n\n          if (this.queued() === 0) {\n            return this.Promise.resolve(null);\n          }\n\n          queue = this._queues.getFirst();\n          ({\n            options,\n            args\n          } = next = queue.first());\n\n          if (capacity != null && options.weight > capacity) {\n            return this.Promise.resolve(null);\n          }\n\n          this.Events.trigger(\"debug\", `Draining ${options.id}`, {\n            args,\n            options\n          });\n          index = this._randomIndex();\n          return this._store.__register__(index, options.weight, options.expiration).then(_ref => {\n            let {\n              success,\n              wait,\n              reservoir\n            } = _ref;\n            var empty;\n            this.Events.trigger(\"debug\", `Drained ${options.id}`, {\n              success,\n              args,\n              options\n            });\n\n            if (success) {\n              queue.shift();\n              empty = this.empty();\n\n              if (empty) {\n                this.Events.trigger(\"empty\");\n              }\n\n              if (reservoir === 0) {\n                this.Events.trigger(\"depleted\", empty);\n              }\n\n              this._run(index, next, wait);\n\n              return this.Promise.resolve(options.weight);\n            } else {\n              return this.Promise.resolve(null);\n            }\n          });\n        });\n      }\n\n      _drainAll(capacity) {\n        let total = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        return this._drainOne(capacity).then(drained => {\n          var newCapacity;\n\n          if (drained != null) {\n            newCapacity = capacity != null ? capacity - drained : capacity;\n            return this._drainAll(newCapacity, total + drained);\n          } else {\n            return this.Promise.resolve(total);\n          }\n        }).catch(e => {\n          return this.Events.trigger(\"error\", e);\n        });\n      }\n\n      _dropAllQueued(message) {\n        return this._queues.shiftAll(function (job) {\n          return job.doDrop({\n            message\n          });\n        });\n      }\n\n      stop() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var done, waitForExecuting;\n        options = parser$5.load(options, this.stopDefaults);\n\n        waitForExecuting = at => {\n          var finished;\n\n          finished = () => {\n            var counts;\n            counts = this._states.counts;\n            return counts[0] + counts[1] + counts[2] + counts[3] === at;\n          };\n\n          return new this.Promise((resolve, reject) => {\n            if (finished()) {\n              return resolve();\n            } else {\n              return this.on(\"done\", () => {\n                if (finished()) {\n                  this.removeAllListeners(\"done\");\n                  return resolve();\n                }\n              });\n            }\n          });\n        };\n\n        done = options.dropWaitingJobs ? (this._run = function (index, next) {\n          return next.doDrop({\n            message: options.dropErrorMessage\n          });\n        }, this._drainOne = () => {\n          return this.Promise.resolve(null);\n        }, this._registerLock.schedule(() => {\n          return this._submitLock.schedule(() => {\n            var k, ref, v;\n            ref = this._scheduled;\n\n            for (k in ref) {\n              v = ref[k];\n\n              if (this.jobStatus(v.job.options.id) === \"RUNNING\") {\n                clearTimeout(v.timeout);\n                clearTimeout(v.expiration);\n                v.job.doDrop({\n                  message: options.dropErrorMessage\n                });\n              }\n            }\n\n            this._dropAllQueued(options.dropErrorMessage);\n\n            return waitForExecuting(0);\n          });\n        })) : this.schedule({\n          priority: NUM_PRIORITIES$1 - 1,\n          weight: 0\n        }, () => {\n          return waitForExecuting(1);\n        });\n\n        this._receive = function (job) {\n          return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));\n        };\n\n        this.stop = () => {\n          return this.Promise.reject(new Bottleneck.prototype.BottleneckError(\"stop() has already been called\"));\n        };\n\n        return done;\n      }\n\n      async _addToQueue(job) {\n        var args, blocked, error, options, reachedHWM, shifted, strategy;\n        ({\n          args,\n          options\n        } = job);\n\n        try {\n          ({\n            reachedHWM,\n            blocked,\n            strategy\n          } = await this._store.__submit__(this.queued(), options.weight));\n        } catch (error1) {\n          error = error1;\n          this.Events.trigger(\"debug\", `Could not queue ${options.id}`, {\n            args,\n            options,\n            error\n          });\n          job.doDrop({\n            error\n          });\n          return false;\n        }\n\n        if (blocked) {\n          job.doDrop();\n          return true;\n        } else if (reachedHWM) {\n          shifted = strategy === Bottleneck.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;\n\n          if (shifted != null) {\n            shifted.doDrop();\n          }\n\n          if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {\n            if (shifted == null) {\n              job.doDrop();\n            }\n\n            return reachedHWM;\n          }\n        }\n\n        job.doQueue(reachedHWM, blocked);\n\n        this._queues.push(job);\n\n        await this._drainAll();\n        return reachedHWM;\n      }\n\n      _receive(job) {\n        if (this._states.jobStatus(job.options.id) != null) {\n          job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));\n\n          return false;\n        } else {\n          job.doReceive();\n          return this._submitLock.schedule(this._addToQueue, job);\n        }\n      }\n\n      submit() {\n        var _this2 = this;\n\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        var cb, fn, job, options, ref, ref1, task;\n\n        if (typeof args[0] === \"function\") {\n          ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);\n          options = parser$5.load({}, this.jobDefaults);\n        } else {\n          ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);\n          options = parser$5.load(options, this.jobDefaults);\n        }\n\n        task = function () {\n          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            args[_key5] = arguments[_key5];\n          }\n\n          return new _this2.Promise(function (resolve, reject) {\n            return fn(...args, function () {\n              for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n                args[_key6] = arguments[_key6];\n              }\n\n              return (args[0] != null ? reject : resolve)(args);\n            });\n          });\n        };\n\n        job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n        job.promise.then(function (args) {\n          return typeof cb === \"function\" ? cb(...args) : void 0;\n        }).catch(function (args) {\n          if (Array.isArray(args)) {\n            return typeof cb === \"function\" ? cb(...args) : void 0;\n          } else {\n            return typeof cb === \"function\" ? cb(args) : void 0;\n          }\n        });\n        return this._receive(job);\n      }\n\n      schedule() {\n        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          args[_key7] = arguments[_key7];\n        }\n\n        var job, options, task;\n\n        if (typeof args[0] === \"function\") {\n          [task, ...args] = args;\n          options = {};\n        } else {\n          [options, task, ...args] = args;\n        }\n\n        job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n\n        this._receive(job);\n\n        return job.promise;\n      }\n\n      wrap(fn) {\n        var schedule, wrapped;\n        schedule = this.schedule.bind(this);\n\n        wrapped = function () {\n          for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n            args[_key8] = arguments[_key8];\n          }\n\n          return schedule(fn.bind(this), ...args);\n        };\n\n        wrapped.withOptions = function (options) {\n          for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n            args[_key9 - 1] = arguments[_key9];\n          }\n\n          return schedule(options, fn, ...args);\n        };\n\n        return wrapped;\n      }\n\n      async updateSettings() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));\n        parser$5.overwrite(options, this.instanceDefaults, this);\n        return this;\n      }\n\n      currentReservoir() {\n        return this._store.__currentReservoir__();\n      }\n\n      incrementReservoir() {\n        let incr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this._store.__incrementReservoir__(incr);\n      }\n\n    }\n\n    Bottleneck.default = Bottleneck;\n    Bottleneck.Events = Events$4;\n    Bottleneck.version = Bottleneck.prototype.version = require$$8.version;\n    Bottleneck.strategy = Bottleneck.prototype.strategy = {\n      LEAK: 1,\n      OVERFLOW: 2,\n      OVERFLOW_PRIORITY: 4,\n      BLOCK: 3\n    };\n    Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = BottleneckError_1;\n    Bottleneck.Group = Bottleneck.prototype.Group = Group_1;\n    Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require$$2;\n    Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require$$3;\n    Bottleneck.Batcher = Bottleneck.prototype.Batcher = Batcher_1;\n    Bottleneck.prototype.jobDefaults = {\n      priority: DEFAULT_PRIORITY$1,\n      weight: 1,\n      expiration: null,\n      id: \"<no-id>\"\n    };\n    Bottleneck.prototype.storeDefaults = {\n      maxConcurrent: null,\n      minTime: 0,\n      highWater: null,\n      strategy: Bottleneck.prototype.strategy.LEAK,\n      penalty: null,\n      reservoir: null,\n      reservoirRefreshInterval: null,\n      reservoirRefreshAmount: null,\n      reservoirIncreaseInterval: null,\n      reservoirIncreaseAmount: null,\n      reservoirIncreaseMaximum: null\n    };\n    Bottleneck.prototype.localStoreDefaults = {\n      Promise: Promise,\n      timeout: null,\n      heartbeatInterval: 250\n    };\n    Bottleneck.prototype.redisStoreDefaults = {\n      Promise: Promise,\n      timeout: null,\n      heartbeatInterval: 5000,\n      clientTimeout: 10000,\n      Redis: null,\n      clientOptions: {},\n      clusterNodes: null,\n      clearDatastore: false,\n      connection: null\n    };\n    Bottleneck.prototype.instanceDefaults = {\n      datastore: \"local\",\n      connection: null,\n      id: \"<no-id>\",\n      rejectOnDrop: true,\n      trackDoneStatus: false,\n      Promise: Promise\n    };\n    Bottleneck.prototype.stopDefaults = {\n      enqueueErrorMessage: \"This limiter has been stopped and cannot accept new jobs.\",\n      dropWaitingJobs: true,\n      dropErrorMessage: \"This limiter has been stopped.\"\n    };\n    return Bottleneck;\n  }.call(commonjsGlobal);\n\n  var Bottleneck_1 = Bottleneck;\n  var lib = Bottleneck_1;\n  return lib;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","Bottleneck","commonjsGlobal","globalThis","window","self","getCjsExportFromNamespace","n","load","received","defaults","onto","k","ref","v","overwrite","parser","DLList","constructor","incr","decr","_first","_last","length","push","value","node","prev","next","shift","first","getArray","results","forEachShift","cb","debug","ref1","ref2","DLList_1","Events","instance","_events","on","once","removeAllListeners","Error","name","_addListener","status","base","listenerCount","trigger","args","e","promises","filter","listener","map","returned","then","error","Promise","all","find","x","Events_1","DLList$1","Events$1","Queues","num_priorities","i","_length","_lists","j","call","job","options","priority","queued","shiftAll","fn","forEach","list","getFirst","arr","len","shiftLastFrom","slice","reverse","Queues_1","BottleneckError","BottleneckError_1","BottleneckError$1","DEFAULT_PRIORITY","Job","NUM_PRIORITIES","parser$1","task","jobDefaults","rejectOnDrop","_states","_sanitizePriority","id","_randomIndex","promise","_resolve","_reject","retryCount","sProperty","Math","random","toString","doDrop","message","remove","_assertStatus","expected","jobStatus","doReceive","start","doQueue","reachedHWM","blocked","doRun","doExecute","chained","clearGlobalState","run","free","eventInfo","passed","schedule","doDone","error1","_onFailure","doExpire","expiration","retry","retryAfter","Job_1","BottleneckError$2","LocalDatastore","parser$2","storeOptions","storeInstanceOptions","clientId","_nextRequest","_lastReservoirRefresh","_lastReservoirIncrease","Date","now","_running","_done","_unblockTime","ready","resolve","clients","_startHeartbeat","heartbeat","reservoirRefreshInterval","reservoirRefreshAmount","reservoirIncreaseInterval","reservoirIncreaseAmount","setInterval","amount","maximum","reservoir","_drainAll","computeCapacity","reservoirIncreaseMaximum","min","heartbeatInterval","unref","clearInterval","__publish__","yieldLoop","__disconnect__","flush","t","reject","setTimeout","computePenalty","penalty","minTime","__updateSettings__","__running__","__queued__","__done__","__groupCheck__","time","timeout","maxConcurrent","conditionsCheck","weight","capacity","__incrementReservoir__","__currentReservoir__","isBlocked","check","__check__","__register__","index","wait","max","success","strategyIsBlock","strategy","__submit__","queueLength","highWater","_dropAllQueued","__free__","running","LocalDatastore_1","BottleneckError$3","States","status1","_jobs","counts","current","initial","statusJobs","pos","indexOf","join","Object","keys","statusCounts","reduce","acc","States_1","DLList$2","Sync","bind","_queue","isEmpty","_tryToRun","Sync_1","version","version$1","version$2","freeze","default","require$$2","console","log","require$$3","require$$4","Events$2","Group","IORedisConnection$1","RedisConnection$1","Scripts$1","parser$3","limiterOptions","deleteKey","instances","Bottleneck_1","_startAutoCleanup","sharedConnection","connection","datastore","assign","key","limiter","deleted","__runCommand__","allKeys","disconnect","limiters","clusterKeys","cursor","end","found","interval","_store","updateSettings","prototype","Group_1","Batcher","Events$3","parser$4","_arr","_resetPromise","_lastFlush","_promise","res","rej","_flush","clearTimeout","_timeout","add","data","ret","maxSize","maxTime","Batcher_1","require$$4$1","require$$8","DEFAULT_PRIORITY$1","Events$4","Job$1","LocalDatastore$1","NUM_PRIORITIES$1","Queues$1","RedisDatastore$1","States$1","Sync$1","parser$5","splice","_addToQueue","invalid","_validateOptions","instanceDefaults","_queues","_scheduled","concat","trackDoneStatus","_limiter","_submitLock","_registerLock","storeDefaults","redisStoreDefaults","localStoreDefaults","channel","channel_client","publish","chain","clusterQueued","empty","done","jobs","_clearGlobalState","_free","_run","_drainOne","queue","total","drained","newCapacity","catch","stop","waitForExecuting","stopDefaults","at","finished","dropWaitingJobs","dropErrorMessage","_receive","enqueueErrorMessage","shifted","LEAK","OVERFLOW_PRIORITY","OVERFLOW","submit","Array","isArray","wrap","wrapped","withOptions","currentReservoir","incrementReservoir","BLOCK","RedisConnection","IORedisConnection","clientTimeout","Redis","clientOptions","clusterNodes","clearDatastore","lib"],"sources":["/home/hosainy/documents/oden-project/repos/sas-interview-assignment/node_modules/bottleneck/light.js"],"sourcesContent":["/**\n  * This file contains the Bottleneck library (MIT), compiled to ES2017, and without Clustering support.\n  * https://github.com/SGrondin/bottleneck\n  */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.Bottleneck = factory());\n}(this, (function () { 'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n['default'] || n;\n\t}\n\n\tvar load = function(received, defaults, onto = {}) {\n\t  var k, ref, v;\n\t  for (k in defaults) {\n\t    v = defaults[k];\n\t    onto[k] = (ref = received[k]) != null ? ref : v;\n\t  }\n\t  return onto;\n\t};\n\n\tvar overwrite = function(received, defaults, onto = {}) {\n\t  var k, v;\n\t  for (k in received) {\n\t    v = received[k];\n\t    if (defaults[k] !== void 0) {\n\t      onto[k] = v;\n\t    }\n\t  }\n\t  return onto;\n\t};\n\n\tvar parser = {\n\t\tload: load,\n\t\toverwrite: overwrite\n\t};\n\n\tvar DLList;\n\n\tDLList = class DLList {\n\t  constructor(incr, decr) {\n\t    this.incr = incr;\n\t    this.decr = decr;\n\t    this._first = null;\n\t    this._last = null;\n\t    this.length = 0;\n\t  }\n\n\t  push(value) {\n\t    var node;\n\t    this.length++;\n\t    if (typeof this.incr === \"function\") {\n\t      this.incr();\n\t    }\n\t    node = {\n\t      value,\n\t      prev: this._last,\n\t      next: null\n\t    };\n\t    if (this._last != null) {\n\t      this._last.next = node;\n\t      this._last = node;\n\t    } else {\n\t      this._first = this._last = node;\n\t    }\n\t    return void 0;\n\t  }\n\n\t  shift() {\n\t    var value;\n\t    if (this._first == null) {\n\t      return;\n\t    } else {\n\t      this.length--;\n\t      if (typeof this.decr === \"function\") {\n\t        this.decr();\n\t      }\n\t    }\n\t    value = this._first.value;\n\t    if ((this._first = this._first.next) != null) {\n\t      this._first.prev = null;\n\t    } else {\n\t      this._last = null;\n\t    }\n\t    return value;\n\t  }\n\n\t  first() {\n\t    if (this._first != null) {\n\t      return this._first.value;\n\t    }\n\t  }\n\n\t  getArray() {\n\t    var node, ref, results;\n\t    node = this._first;\n\t    results = [];\n\t    while (node != null) {\n\t      results.push((ref = node, node = node.next, ref.value));\n\t    }\n\t    return results;\n\t  }\n\n\t  forEachShift(cb) {\n\t    var node;\n\t    node = this.shift();\n\t    while (node != null) {\n\t      (cb(node), node = this.shift());\n\t    }\n\t    return void 0;\n\t  }\n\n\t  debug() {\n\t    var node, ref, ref1, ref2, results;\n\t    node = this._first;\n\t    results = [];\n\t    while (node != null) {\n\t      results.push((ref = node, node = node.next, {\n\t        value: ref.value,\n\t        prev: (ref1 = ref.prev) != null ? ref1.value : void 0,\n\t        next: (ref2 = ref.next) != null ? ref2.value : void 0\n\t      }));\n\t    }\n\t    return results;\n\t  }\n\n\t};\n\n\tvar DLList_1 = DLList;\n\n\tvar Events;\n\n\tEvents = class Events {\n\t  constructor(instance) {\n\t    this.instance = instance;\n\t    this._events = {};\n\t    if ((this.instance.on != null) || (this.instance.once != null) || (this.instance.removeAllListeners != null)) {\n\t      throw new Error(\"An Emitter already exists for this object\");\n\t    }\n\t    this.instance.on = (name, cb) => {\n\t      return this._addListener(name, \"many\", cb);\n\t    };\n\t    this.instance.once = (name, cb) => {\n\t      return this._addListener(name, \"once\", cb);\n\t    };\n\t    this.instance.removeAllListeners = (name = null) => {\n\t      if (name != null) {\n\t        return delete this._events[name];\n\t      } else {\n\t        return this._events = {};\n\t      }\n\t    };\n\t  }\n\n\t  _addListener(name, status, cb) {\n\t    var base;\n\t    if ((base = this._events)[name] == null) {\n\t      base[name] = [];\n\t    }\n\t    this._events[name].push({cb, status});\n\t    return this.instance;\n\t  }\n\n\t  listenerCount(name) {\n\t    if (this._events[name] != null) {\n\t      return this._events[name].length;\n\t    } else {\n\t      return 0;\n\t    }\n\t  }\n\n\t  async trigger(name, ...args) {\n\t    var e, promises;\n\t    try {\n\t      if (name !== \"debug\") {\n\t        this.trigger(\"debug\", `Event triggered: ${name}`, args);\n\t      }\n\t      if (this._events[name] == null) {\n\t        return;\n\t      }\n\t      this._events[name] = this._events[name].filter(function(listener) {\n\t        return listener.status !== \"none\";\n\t      });\n\t      promises = this._events[name].map(async(listener) => {\n\t        var e, returned;\n\t        if (listener.status === \"none\") {\n\t          return;\n\t        }\n\t        if (listener.status === \"once\") {\n\t          listener.status = \"none\";\n\t        }\n\t        try {\n\t          returned = typeof listener.cb === \"function\" ? listener.cb(...args) : void 0;\n\t          if (typeof (returned != null ? returned.then : void 0) === \"function\") {\n\t            return (await returned);\n\t          } else {\n\t            return returned;\n\t          }\n\t        } catch (error) {\n\t          e = error;\n\t          {\n\t            this.trigger(\"error\", e);\n\t          }\n\t          return null;\n\t        }\n\t      });\n\t      return ((await Promise.all(promises))).find(function(x) {\n\t        return x != null;\n\t      });\n\t    } catch (error) {\n\t      e = error;\n\t      {\n\t        this.trigger(\"error\", e);\n\t      }\n\t      return null;\n\t    }\n\t  }\n\n\t};\n\n\tvar Events_1 = Events;\n\n\tvar DLList$1, Events$1, Queues;\n\n\tDLList$1 = DLList_1;\n\n\tEvents$1 = Events_1;\n\n\tQueues = class Queues {\n\t  constructor(num_priorities) {\n\t    var i;\n\t    this.Events = new Events$1(this);\n\t    this._length = 0;\n\t    this._lists = (function() {\n\t      var j, ref, results;\n\t      results = [];\n\t      for (i = j = 1, ref = num_priorities; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {\n\t        results.push(new DLList$1((() => {\n\t          return this.incr();\n\t        }), (() => {\n\t          return this.decr();\n\t        })));\n\t      }\n\t      return results;\n\t    }).call(this);\n\t  }\n\n\t  incr() {\n\t    if (this._length++ === 0) {\n\t      return this.Events.trigger(\"leftzero\");\n\t    }\n\t  }\n\n\t  decr() {\n\t    if (--this._length === 0) {\n\t      return this.Events.trigger(\"zero\");\n\t    }\n\t  }\n\n\t  push(job) {\n\t    return this._lists[job.options.priority].push(job);\n\t  }\n\n\t  queued(priority) {\n\t    if (priority != null) {\n\t      return this._lists[priority].length;\n\t    } else {\n\t      return this._length;\n\t    }\n\t  }\n\n\t  shiftAll(fn) {\n\t    return this._lists.forEach(function(list) {\n\t      return list.forEachShift(fn);\n\t    });\n\t  }\n\n\t  getFirst(arr = this._lists) {\n\t    var j, len, list;\n\t    for (j = 0, len = arr.length; j < len; j++) {\n\t      list = arr[j];\n\t      if (list.length > 0) {\n\t        return list;\n\t      }\n\t    }\n\t    return [];\n\t  }\n\n\t  shiftLastFrom(priority) {\n\t    return this.getFirst(this._lists.slice(priority).reverse()).shift();\n\t  }\n\n\t};\n\n\tvar Queues_1 = Queues;\n\n\tvar BottleneckError;\n\n\tBottleneckError = class BottleneckError extends Error {};\n\n\tvar BottleneckError_1 = BottleneckError;\n\n\tvar BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;\n\n\tNUM_PRIORITIES = 10;\n\n\tDEFAULT_PRIORITY = 5;\n\n\tparser$1 = parser;\n\n\tBottleneckError$1 = BottleneckError_1;\n\n\tJob = class Job {\n\t  constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise) {\n\t    this.task = task;\n\t    this.args = args;\n\t    this.rejectOnDrop = rejectOnDrop;\n\t    this.Events = Events;\n\t    this._states = _states;\n\t    this.Promise = Promise;\n\t    this.options = parser$1.load(options, jobDefaults);\n\t    this.options.priority = this._sanitizePriority(this.options.priority);\n\t    if (this.options.id === jobDefaults.id) {\n\t      this.options.id = `${this.options.id}-${this._randomIndex()}`;\n\t    }\n\t    this.promise = new this.Promise((_resolve, _reject) => {\n\t      this._resolve = _resolve;\n\t      this._reject = _reject;\n\t    });\n\t    this.retryCount = 0;\n\t  }\n\n\t  _sanitizePriority(priority) {\n\t    var sProperty;\n\t    sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;\n\t    if (sProperty < 0) {\n\t      return 0;\n\t    } else if (sProperty > NUM_PRIORITIES - 1) {\n\t      return NUM_PRIORITIES - 1;\n\t    } else {\n\t      return sProperty;\n\t    }\n\t  }\n\n\t  _randomIndex() {\n\t    return Math.random().toString(36).slice(2);\n\t  }\n\n\t  doDrop({error, message = \"This job has been dropped by Bottleneck\"} = {}) {\n\t    if (this._states.remove(this.options.id)) {\n\t      if (this.rejectOnDrop) {\n\t        this._reject(error != null ? error : new BottleneckError$1(message));\n\t      }\n\t      this.Events.trigger(\"dropped\", {args: this.args, options: this.options, task: this.task, promise: this.promise});\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\n\t  _assertStatus(expected) {\n\t    var status;\n\t    status = this._states.jobStatus(this.options.id);\n\t    if (!(status === expected || (expected === \"DONE\" && status === null))) {\n\t      throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);\n\t    }\n\t  }\n\n\t  doReceive() {\n\t    this._states.start(this.options.id);\n\t    return this.Events.trigger(\"received\", {args: this.args, options: this.options});\n\t  }\n\n\t  doQueue(reachedHWM, blocked) {\n\t    this._assertStatus(\"RECEIVED\");\n\t    this._states.next(this.options.id);\n\t    return this.Events.trigger(\"queued\", {args: this.args, options: this.options, reachedHWM, blocked});\n\t  }\n\n\t  doRun() {\n\t    if (this.retryCount === 0) {\n\t      this._assertStatus(\"QUEUED\");\n\t      this._states.next(this.options.id);\n\t    } else {\n\t      this._assertStatus(\"EXECUTING\");\n\t    }\n\t    return this.Events.trigger(\"scheduled\", {args: this.args, options: this.options});\n\t  }\n\n\t  async doExecute(chained, clearGlobalState, run, free) {\n\t    var error, eventInfo, passed;\n\t    if (this.retryCount === 0) {\n\t      this._assertStatus(\"RUNNING\");\n\t      this._states.next(this.options.id);\n\t    } else {\n\t      this._assertStatus(\"EXECUTING\");\n\t    }\n\t    eventInfo = {args: this.args, options: this.options, retryCount: this.retryCount};\n\t    this.Events.trigger(\"executing\", eventInfo);\n\t    try {\n\t      passed = (await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args)));\n\t      if (clearGlobalState()) {\n\t        this.doDone(eventInfo);\n\t        await free(this.options, eventInfo);\n\t        this._assertStatus(\"DONE\");\n\t        return this._resolve(passed);\n\t      }\n\t    } catch (error1) {\n\t      error = error1;\n\t      return this._onFailure(error, eventInfo, clearGlobalState, run, free);\n\t    }\n\t  }\n\n\t  doExpire(clearGlobalState, run, free) {\n\t    var error, eventInfo;\n\t    if (this._states.jobStatus(this.options.id === \"RUNNING\")) {\n\t      this._states.next(this.options.id);\n\t    }\n\t    this._assertStatus(\"EXECUTING\");\n\t    eventInfo = {args: this.args, options: this.options, retryCount: this.retryCount};\n\t    error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);\n\t    return this._onFailure(error, eventInfo, clearGlobalState, run, free);\n\t  }\n\n\t  async _onFailure(error, eventInfo, clearGlobalState, run, free) {\n\t    var retry, retryAfter;\n\t    if (clearGlobalState()) {\n\t      retry = (await this.Events.trigger(\"failed\", error, eventInfo));\n\t      if (retry != null) {\n\t        retryAfter = ~~retry;\n\t        this.Events.trigger(\"retry\", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);\n\t        this.retryCount++;\n\t        return run(retryAfter);\n\t      } else {\n\t        this.doDone(eventInfo);\n\t        await free(this.options, eventInfo);\n\t        this._assertStatus(\"DONE\");\n\t        return this._reject(error);\n\t      }\n\t    }\n\t  }\n\n\t  doDone(eventInfo) {\n\t    this._assertStatus(\"EXECUTING\");\n\t    this._states.next(this.options.id);\n\t    return this.Events.trigger(\"done\", eventInfo);\n\t  }\n\n\t};\n\n\tvar Job_1 = Job;\n\n\tvar BottleneckError$2, LocalDatastore, parser$2;\n\n\tparser$2 = parser;\n\n\tBottleneckError$2 = BottleneckError_1;\n\n\tLocalDatastore = class LocalDatastore {\n\t  constructor(instance, storeOptions, storeInstanceOptions) {\n\t    this.instance = instance;\n\t    this.storeOptions = storeOptions;\n\t    this.clientId = this.instance._randomIndex();\n\t    parser$2.load(storeInstanceOptions, storeInstanceOptions, this);\n\t    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\n\t    this._running = 0;\n\t    this._done = 0;\n\t    this._unblockTime = 0;\n\t    this.ready = this.Promise.resolve();\n\t    this.clients = {};\n\t    this._startHeartbeat();\n\t  }\n\n\t  _startHeartbeat() {\n\t    var base;\n\t    if ((this.heartbeat == null) && (((this.storeOptions.reservoirRefreshInterval != null) && (this.storeOptions.reservoirRefreshAmount != null)) || ((this.storeOptions.reservoirIncreaseInterval != null) && (this.storeOptions.reservoirIncreaseAmount != null)))) {\n\t      return typeof (base = (this.heartbeat = setInterval(() => {\n\t        var amount, incr, maximum, now, reservoir;\n\t        now = Date.now();\n\t        if ((this.storeOptions.reservoirRefreshInterval != null) && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\n\t          this._lastReservoirRefresh = now;\n\t          this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\n\t          this.instance._drainAll(this.computeCapacity());\n\t        }\n\t        if ((this.storeOptions.reservoirIncreaseInterval != null) && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\n\t          ({\n\t            reservoirIncreaseAmount: amount,\n\t            reservoirIncreaseMaximum: maximum,\n\t            reservoir\n\t          } = this.storeOptions);\n\t          this._lastReservoirIncrease = now;\n\t          incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\n\t          if (incr > 0) {\n\t            this.storeOptions.reservoir += incr;\n\t            return this.instance._drainAll(this.computeCapacity());\n\t          }\n\t        }\n\t      }, this.heartbeatInterval))).unref === \"function\" ? base.unref() : void 0;\n\t    } else {\n\t      return clearInterval(this.heartbeat);\n\t    }\n\t  }\n\n\t  async __publish__(message) {\n\t    await this.yieldLoop();\n\t    return this.instance.Events.trigger(\"message\", message.toString());\n\t  }\n\n\t  async __disconnect__(flush) {\n\t    await this.yieldLoop();\n\t    clearInterval(this.heartbeat);\n\t    return this.Promise.resolve();\n\t  }\n\n\t  yieldLoop(t = 0) {\n\t    return new this.Promise(function(resolve, reject) {\n\t      return setTimeout(resolve, t);\n\t    });\n\t  }\n\n\t  computePenalty() {\n\t    var ref;\n\t    return (ref = this.storeOptions.penalty) != null ? ref : (15 * this.storeOptions.minTime) || 5000;\n\t  }\n\n\t  async __updateSettings__(options) {\n\t    await this.yieldLoop();\n\t    parser$2.overwrite(options, options, this.storeOptions);\n\t    this._startHeartbeat();\n\t    this.instance._drainAll(this.computeCapacity());\n\t    return true;\n\t  }\n\n\t  async __running__() {\n\t    await this.yieldLoop();\n\t    return this._running;\n\t  }\n\n\t  async __queued__() {\n\t    await this.yieldLoop();\n\t    return this.instance.queued();\n\t  }\n\n\t  async __done__() {\n\t    await this.yieldLoop();\n\t    return this._done;\n\t  }\n\n\t  async __groupCheck__(time) {\n\t    await this.yieldLoop();\n\t    return (this._nextRequest + this.timeout) < time;\n\t  }\n\n\t  computeCapacity() {\n\t    var maxConcurrent, reservoir;\n\t    ({maxConcurrent, reservoir} = this.storeOptions);\n\t    if ((maxConcurrent != null) && (reservoir != null)) {\n\t      return Math.min(maxConcurrent - this._running, reservoir);\n\t    } else if (maxConcurrent != null) {\n\t      return maxConcurrent - this._running;\n\t    } else if (reservoir != null) {\n\t      return reservoir;\n\t    } else {\n\t      return null;\n\t    }\n\t  }\n\n\t  conditionsCheck(weight) {\n\t    var capacity;\n\t    capacity = this.computeCapacity();\n\t    return (capacity == null) || weight <= capacity;\n\t  }\n\n\t  async __incrementReservoir__(incr) {\n\t    var reservoir;\n\t    await this.yieldLoop();\n\t    reservoir = this.storeOptions.reservoir += incr;\n\t    this.instance._drainAll(this.computeCapacity());\n\t    return reservoir;\n\t  }\n\n\t  async __currentReservoir__() {\n\t    await this.yieldLoop();\n\t    return this.storeOptions.reservoir;\n\t  }\n\n\t  isBlocked(now) {\n\t    return this._unblockTime >= now;\n\t  }\n\n\t  check(weight, now) {\n\t    return this.conditionsCheck(weight) && (this._nextRequest - now) <= 0;\n\t  }\n\n\t  async __check__(weight) {\n\t    var now;\n\t    await this.yieldLoop();\n\t    now = Date.now();\n\t    return this.check(weight, now);\n\t  }\n\n\t  async __register__(index, weight, expiration) {\n\t    var now, wait;\n\t    await this.yieldLoop();\n\t    now = Date.now();\n\t    if (this.conditionsCheck(weight)) {\n\t      this._running += weight;\n\t      if (this.storeOptions.reservoir != null) {\n\t        this.storeOptions.reservoir -= weight;\n\t      }\n\t      wait = Math.max(this._nextRequest - now, 0);\n\t      this._nextRequest = now + wait + this.storeOptions.minTime;\n\t      return {\n\t        success: true,\n\t        wait,\n\t        reservoir: this.storeOptions.reservoir\n\t      };\n\t    } else {\n\t      return {\n\t        success: false\n\t      };\n\t    }\n\t  }\n\n\t  strategyIsBlock() {\n\t    return this.storeOptions.strategy === 3;\n\t  }\n\n\t  async __submit__(queueLength, weight) {\n\t    var blocked, now, reachedHWM;\n\t    await this.yieldLoop();\n\t    if ((this.storeOptions.maxConcurrent != null) && weight > this.storeOptions.maxConcurrent) {\n\t      throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);\n\t    }\n\t    now = Date.now();\n\t    reachedHWM = (this.storeOptions.highWater != null) && queueLength === this.storeOptions.highWater && !this.check(weight, now);\n\t    blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));\n\t    if (blocked) {\n\t      this._unblockTime = now + this.computePenalty();\n\t      this._nextRequest = this._unblockTime + this.storeOptions.minTime;\n\t      this.instance._dropAllQueued();\n\t    }\n\t    return {\n\t      reachedHWM,\n\t      blocked,\n\t      strategy: this.storeOptions.strategy\n\t    };\n\t  }\n\n\t  async __free__(index, weight) {\n\t    await this.yieldLoop();\n\t    this._running -= weight;\n\t    this._done += weight;\n\t    this.instance._drainAll(this.computeCapacity());\n\t    return {\n\t      running: this._running\n\t    };\n\t  }\n\n\t};\n\n\tvar LocalDatastore_1 = LocalDatastore;\n\n\tvar BottleneckError$3, States;\n\n\tBottleneckError$3 = BottleneckError_1;\n\n\tStates = class States {\n\t  constructor(status1) {\n\t    this.status = status1;\n\t    this._jobs = {};\n\t    this.counts = this.status.map(function() {\n\t      return 0;\n\t    });\n\t  }\n\n\t  next(id) {\n\t    var current, next;\n\t    current = this._jobs[id];\n\t    next = current + 1;\n\t    if ((current != null) && next < this.status.length) {\n\t      this.counts[current]--;\n\t      this.counts[next]++;\n\t      return this._jobs[id]++;\n\t    } else if (current != null) {\n\t      this.counts[current]--;\n\t      return delete this._jobs[id];\n\t    }\n\t  }\n\n\t  start(id) {\n\t    var initial;\n\t    initial = 0;\n\t    this._jobs[id] = initial;\n\t    return this.counts[initial]++;\n\t  }\n\n\t  remove(id) {\n\t    var current;\n\t    current = this._jobs[id];\n\t    if (current != null) {\n\t      this.counts[current]--;\n\t      delete this._jobs[id];\n\t    }\n\t    return current != null;\n\t  }\n\n\t  jobStatus(id) {\n\t    var ref;\n\t    return (ref = this.status[this._jobs[id]]) != null ? ref : null;\n\t  }\n\n\t  statusJobs(status) {\n\t    var k, pos, ref, results, v;\n\t    if (status != null) {\n\t      pos = this.status.indexOf(status);\n\t      if (pos < 0) {\n\t        throw new BottleneckError$3(`status must be one of ${this.status.join(', ')}`);\n\t      }\n\t      ref = this._jobs;\n\t      results = [];\n\t      for (k in ref) {\n\t        v = ref[k];\n\t        if (v === pos) {\n\t          results.push(k);\n\t        }\n\t      }\n\t      return results;\n\t    } else {\n\t      return Object.keys(this._jobs);\n\t    }\n\t  }\n\n\t  statusCounts() {\n\t    return this.counts.reduce(((acc, v, i) => {\n\t      acc[this.status[i]] = v;\n\t      return acc;\n\t    }), {});\n\t  }\n\n\t};\n\n\tvar States_1 = States;\n\n\tvar DLList$2, Sync;\n\n\tDLList$2 = DLList_1;\n\n\tSync = class Sync {\n\t  constructor(name, Promise) {\n\t    this.schedule = this.schedule.bind(this);\n\t    this.name = name;\n\t    this.Promise = Promise;\n\t    this._running = 0;\n\t    this._queue = new DLList$2();\n\t  }\n\n\t  isEmpty() {\n\t    return this._queue.length === 0;\n\t  }\n\n\t  async _tryToRun() {\n\t    var args, cb, error, reject, resolve, returned, task;\n\t    if ((this._running < 1) && this._queue.length > 0) {\n\t      this._running++;\n\t      ({task, args, resolve, reject} = this._queue.shift());\n\t      cb = (await (async function() {\n\t        try {\n\t          returned = (await task(...args));\n\t          return function() {\n\t            return resolve(returned);\n\t          };\n\t        } catch (error1) {\n\t          error = error1;\n\t          return function() {\n\t            return reject(error);\n\t          };\n\t        }\n\t      })());\n\t      this._running--;\n\t      this._tryToRun();\n\t      return cb();\n\t    }\n\t  }\n\n\t  schedule(task, ...args) {\n\t    var promise, reject, resolve;\n\t    resolve = reject = null;\n\t    promise = new this.Promise(function(_resolve, _reject) {\n\t      resolve = _resolve;\n\t      return reject = _reject;\n\t    });\n\t    this._queue.push({task, args, resolve, reject});\n\t    this._tryToRun();\n\t    return promise;\n\t  }\n\n\t};\n\n\tvar Sync_1 = Sync;\n\n\tvar version = \"2.19.5\";\n\tvar version$1 = {\n\t\tversion: version\n\t};\n\n\tvar version$2 = /*#__PURE__*/Object.freeze({\n\t\tversion: version,\n\t\tdefault: version$1\n\t});\n\n\tvar require$$2 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar require$$3 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar require$$4 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;\n\n\tparser$3 = parser;\n\n\tEvents$2 = Events_1;\n\n\tRedisConnection$1 = require$$2;\n\n\tIORedisConnection$1 = require$$3;\n\n\tScripts$1 = require$$4;\n\n\tGroup = (function() {\n\t  class Group {\n\t    constructor(limiterOptions = {}) {\n\t      this.deleteKey = this.deleteKey.bind(this);\n\t      this.limiterOptions = limiterOptions;\n\t      parser$3.load(this.limiterOptions, this.defaults, this);\n\t      this.Events = new Events$2(this);\n\t      this.instances = {};\n\t      this.Bottleneck = Bottleneck_1;\n\t      this._startAutoCleanup();\n\t      this.sharedConnection = this.connection != null;\n\t      if (this.connection == null) {\n\t        if (this.limiterOptions.datastore === \"redis\") {\n\t          this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, {Events: this.Events}));\n\t        } else if (this.limiterOptions.datastore === \"ioredis\") {\n\t          this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, {Events: this.Events}));\n\t        }\n\t      }\n\t    }\n\n\t    key(key = \"\") {\n\t      var ref;\n\t      return (ref = this.instances[key]) != null ? ref : (() => {\n\t        var limiter;\n\t        limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {\n\t          id: `${this.id}-${key}`,\n\t          timeout: this.timeout,\n\t          connection: this.connection\n\t        }));\n\t        this.Events.trigger(\"created\", limiter, key);\n\t        return limiter;\n\t      })();\n\t    }\n\n\t    async deleteKey(key = \"\") {\n\t      var deleted, instance;\n\t      instance = this.instances[key];\n\t      if (this.connection) {\n\t        deleted = (await this.connection.__runCommand__(['del', ...Scripts$1.allKeys(`${this.id}-${key}`)]));\n\t      }\n\t      if (instance != null) {\n\t        delete this.instances[key];\n\t        await instance.disconnect();\n\t      }\n\t      return (instance != null) || deleted > 0;\n\t    }\n\n\t    limiters() {\n\t      var k, ref, results, v;\n\t      ref = this.instances;\n\t      results = [];\n\t      for (k in ref) {\n\t        v = ref[k];\n\t        results.push({\n\t          key: k,\n\t          limiter: v\n\t        });\n\t      }\n\t      return results;\n\t    }\n\n\t    keys() {\n\t      return Object.keys(this.instances);\n\t    }\n\n\t    async clusterKeys() {\n\t      var cursor, end, found, i, k, keys, len, next, start;\n\t      if (this.connection == null) {\n\t        return this.Promise.resolve(this.keys());\n\t      }\n\t      keys = [];\n\t      cursor = null;\n\t      start = `b_${this.id}-`.length;\n\t      end = \"_settings\".length;\n\t      while (cursor !== 0) {\n\t        [next, found] = (await this.connection.__runCommand__([\"scan\", cursor != null ? cursor : 0, \"match\", `b_${this.id}-*_settings`, \"count\", 10000]));\n\t        cursor = ~~next;\n\t        for (i = 0, len = found.length; i < len; i++) {\n\t          k = found[i];\n\t          keys.push(k.slice(start, -end));\n\t        }\n\t      }\n\t      return keys;\n\t    }\n\n\t    _startAutoCleanup() {\n\t      var base;\n\t      clearInterval(this.interval);\n\t      return typeof (base = (this.interval = setInterval(async() => {\n\t        var e, k, ref, results, time, v;\n\t        time = Date.now();\n\t        ref = this.instances;\n\t        results = [];\n\t        for (k in ref) {\n\t          v = ref[k];\n\t          try {\n\t            if ((await v._store.__groupCheck__(time))) {\n\t              results.push(this.deleteKey(k));\n\t            } else {\n\t              results.push(void 0);\n\t            }\n\t          } catch (error) {\n\t            e = error;\n\t            results.push(v.Events.trigger(\"error\", e));\n\t          }\n\t        }\n\t        return results;\n\t      }, this.timeout / 2))).unref === \"function\" ? base.unref() : void 0;\n\t    }\n\n\t    updateSettings(options = {}) {\n\t      parser$3.overwrite(options, this.defaults, this);\n\t      parser$3.overwrite(options, options, this.limiterOptions);\n\t      if (options.timeout != null) {\n\t        return this._startAutoCleanup();\n\t      }\n\t    }\n\n\t    disconnect(flush = true) {\n\t      var ref;\n\t      if (!this.sharedConnection) {\n\t        return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;\n\t      }\n\t    }\n\n\t  }\n\t  Group.prototype.defaults = {\n\t    timeout: 1000 * 60 * 5,\n\t    connection: null,\n\t    Promise: Promise,\n\t    id: \"group-key\"\n\t  };\n\n\t  return Group;\n\n\t}).call(commonjsGlobal);\n\n\tvar Group_1 = Group;\n\n\tvar Batcher, Events$3, parser$4;\n\n\tparser$4 = parser;\n\n\tEvents$3 = Events_1;\n\n\tBatcher = (function() {\n\t  class Batcher {\n\t    constructor(options = {}) {\n\t      this.options = options;\n\t      parser$4.load(this.options, this.defaults, this);\n\t      this.Events = new Events$3(this);\n\t      this._arr = [];\n\t      this._resetPromise();\n\t      this._lastFlush = Date.now();\n\t    }\n\n\t    _resetPromise() {\n\t      return this._promise = new this.Promise((res, rej) => {\n\t        return this._resolve = res;\n\t      });\n\t    }\n\n\t    _flush() {\n\t      clearTimeout(this._timeout);\n\t      this._lastFlush = Date.now();\n\t      this._resolve();\n\t      this.Events.trigger(\"batch\", this._arr);\n\t      this._arr = [];\n\t      return this._resetPromise();\n\t    }\n\n\t    add(data) {\n\t      var ret;\n\t      this._arr.push(data);\n\t      ret = this._promise;\n\t      if (this._arr.length === this.maxSize) {\n\t        this._flush();\n\t      } else if ((this.maxTime != null) && this._arr.length === 1) {\n\t        this._timeout = setTimeout(() => {\n\t          return this._flush();\n\t        }, this.maxTime);\n\t      }\n\t      return ret;\n\t    }\n\n\t  }\n\t  Batcher.prototype.defaults = {\n\t    maxTime: null,\n\t    maxSize: null,\n\t    Promise: Promise\n\t  };\n\n\t  return Batcher;\n\n\t}).call(commonjsGlobal);\n\n\tvar Batcher_1 = Batcher;\n\n\tvar require$$4$1 = () => console.log('You must import the full version of Bottleneck in order to use this feature.');\n\n\tvar require$$8 = getCjsExportFromNamespace(version$2);\n\n\tvar Bottleneck, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5,\n\t  splice = [].splice;\n\n\tNUM_PRIORITIES$1 = 10;\n\n\tDEFAULT_PRIORITY$1 = 5;\n\n\tparser$5 = parser;\n\n\tQueues$1 = Queues_1;\n\n\tJob$1 = Job_1;\n\n\tLocalDatastore$1 = LocalDatastore_1;\n\n\tRedisDatastore$1 = require$$4$1;\n\n\tEvents$4 = Events_1;\n\n\tStates$1 = States_1;\n\n\tSync$1 = Sync_1;\n\n\tBottleneck = (function() {\n\t  class Bottleneck {\n\t    constructor(options = {}, ...invalid) {\n\t      var storeInstanceOptions, storeOptions;\n\t      this._addToQueue = this._addToQueue.bind(this);\n\t      this._validateOptions(options, invalid);\n\t      parser$5.load(options, this.instanceDefaults, this);\n\t      this._queues = new Queues$1(NUM_PRIORITIES$1);\n\t      this._scheduled = {};\n\t      this._states = new States$1([\"RECEIVED\", \"QUEUED\", \"RUNNING\", \"EXECUTING\"].concat(this.trackDoneStatus ? [\"DONE\"] : []));\n\t      this._limiter = null;\n\t      this.Events = new Events$4(this);\n\t      this._submitLock = new Sync$1(\"submit\", this.Promise);\n\t      this._registerLock = new Sync$1(\"register\", this.Promise);\n\t      storeOptions = parser$5.load(options, this.storeDefaults, {});\n\t      this._store = (function() {\n\t        if (this.datastore === \"redis\" || this.datastore === \"ioredis\" || (this.connection != null)) {\n\t          storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});\n\t          return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);\n\t        } else if (this.datastore === \"local\") {\n\t          storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});\n\t          return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);\n\t        } else {\n\t          throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);\n\t        }\n\t      }).call(this);\n\t      this._queues.on(\"leftzero\", () => {\n\t        var ref;\n\t        return (ref = this._store.heartbeat) != null ? typeof ref.ref === \"function\" ? ref.ref() : void 0 : void 0;\n\t      });\n\t      this._queues.on(\"zero\", () => {\n\t        var ref;\n\t        return (ref = this._store.heartbeat) != null ? typeof ref.unref === \"function\" ? ref.unref() : void 0 : void 0;\n\t      });\n\t    }\n\n\t    _validateOptions(options, invalid) {\n\t      if (!((options != null) && typeof options === \"object\" && invalid.length === 0)) {\n\t        throw new Bottleneck.prototype.BottleneckError(\"Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.\");\n\t      }\n\t    }\n\n\t    ready() {\n\t      return this._store.ready;\n\t    }\n\n\t    clients() {\n\t      return this._store.clients;\n\t    }\n\n\t    channel() {\n\t      return `b_${this.id}`;\n\t    }\n\n\t    channel_client() {\n\t      return `b_${this.id}_${this._store.clientId}`;\n\t    }\n\n\t    publish(message) {\n\t      return this._store.__publish__(message);\n\t    }\n\n\t    disconnect(flush = true) {\n\t      return this._store.__disconnect__(flush);\n\t    }\n\n\t    chain(_limiter) {\n\t      this._limiter = _limiter;\n\t      return this;\n\t    }\n\n\t    queued(priority) {\n\t      return this._queues.queued(priority);\n\t    }\n\n\t    clusterQueued() {\n\t      return this._store.__queued__();\n\t    }\n\n\t    empty() {\n\t      return this.queued() === 0 && this._submitLock.isEmpty();\n\t    }\n\n\t    running() {\n\t      return this._store.__running__();\n\t    }\n\n\t    done() {\n\t      return this._store.__done__();\n\t    }\n\n\t    jobStatus(id) {\n\t      return this._states.jobStatus(id);\n\t    }\n\n\t    jobs(status) {\n\t      return this._states.statusJobs(status);\n\t    }\n\n\t    counts() {\n\t      return this._states.statusCounts();\n\t    }\n\n\t    _randomIndex() {\n\t      return Math.random().toString(36).slice(2);\n\t    }\n\n\t    check(weight = 1) {\n\t      return this._store.__check__(weight);\n\t    }\n\n\t    _clearGlobalState(index) {\n\t      if (this._scheduled[index] != null) {\n\t        clearTimeout(this._scheduled[index].expiration);\n\t        delete this._scheduled[index];\n\t        return true;\n\t      } else {\n\t        return false;\n\t      }\n\t    }\n\n\t    async _free(index, job, options, eventInfo) {\n\t      var e, running;\n\t      try {\n\t        ({running} = (await this._store.__free__(index, options.weight)));\n\t        this.Events.trigger(\"debug\", `Freed ${options.id}`, eventInfo);\n\t        if (running === 0 && this.empty()) {\n\t          return this.Events.trigger(\"idle\");\n\t        }\n\t      } catch (error1) {\n\t        e = error1;\n\t        return this.Events.trigger(\"error\", e);\n\t      }\n\t    }\n\n\t    _run(index, job, wait) {\n\t      var clearGlobalState, free, run;\n\t      job.doRun();\n\t      clearGlobalState = this._clearGlobalState.bind(this, index);\n\t      run = this._run.bind(this, index, job);\n\t      free = this._free.bind(this, index, job);\n\t      return this._scheduled[index] = {\n\t        timeout: setTimeout(() => {\n\t          return job.doExecute(this._limiter, clearGlobalState, run, free);\n\t        }, wait),\n\t        expiration: job.options.expiration != null ? setTimeout(function() {\n\t          return job.doExpire(clearGlobalState, run, free);\n\t        }, wait + job.options.expiration) : void 0,\n\t        job: job\n\t      };\n\t    }\n\n\t    _drainOne(capacity) {\n\t      return this._registerLock.schedule(() => {\n\t        var args, index, next, options, queue;\n\t        if (this.queued() === 0) {\n\t          return this.Promise.resolve(null);\n\t        }\n\t        queue = this._queues.getFirst();\n\t        ({options, args} = next = queue.first());\n\t        if ((capacity != null) && options.weight > capacity) {\n\t          return this.Promise.resolve(null);\n\t        }\n\t        this.Events.trigger(\"debug\", `Draining ${options.id}`, {args, options});\n\t        index = this._randomIndex();\n\t        return this._store.__register__(index, options.weight, options.expiration).then(({success, wait, reservoir}) => {\n\t          var empty;\n\t          this.Events.trigger(\"debug\", `Drained ${options.id}`, {success, args, options});\n\t          if (success) {\n\t            queue.shift();\n\t            empty = this.empty();\n\t            if (empty) {\n\t              this.Events.trigger(\"empty\");\n\t            }\n\t            if (reservoir === 0) {\n\t              this.Events.trigger(\"depleted\", empty);\n\t            }\n\t            this._run(index, next, wait);\n\t            return this.Promise.resolve(options.weight);\n\t          } else {\n\t            return this.Promise.resolve(null);\n\t          }\n\t        });\n\t      });\n\t    }\n\n\t    _drainAll(capacity, total = 0) {\n\t      return this._drainOne(capacity).then((drained) => {\n\t        var newCapacity;\n\t        if (drained != null) {\n\t          newCapacity = capacity != null ? capacity - drained : capacity;\n\t          return this._drainAll(newCapacity, total + drained);\n\t        } else {\n\t          return this.Promise.resolve(total);\n\t        }\n\t      }).catch((e) => {\n\t        return this.Events.trigger(\"error\", e);\n\t      });\n\t    }\n\n\t    _dropAllQueued(message) {\n\t      return this._queues.shiftAll(function(job) {\n\t        return job.doDrop({message});\n\t      });\n\t    }\n\n\t    stop(options = {}) {\n\t      var done, waitForExecuting;\n\t      options = parser$5.load(options, this.stopDefaults);\n\t      waitForExecuting = (at) => {\n\t        var finished;\n\t        finished = () => {\n\t          var counts;\n\t          counts = this._states.counts;\n\t          return (counts[0] + counts[1] + counts[2] + counts[3]) === at;\n\t        };\n\t        return new this.Promise((resolve, reject) => {\n\t          if (finished()) {\n\t            return resolve();\n\t          } else {\n\t            return this.on(\"done\", () => {\n\t              if (finished()) {\n\t                this.removeAllListeners(\"done\");\n\t                return resolve();\n\t              }\n\t            });\n\t          }\n\t        });\n\t      };\n\t      done = options.dropWaitingJobs ? (this._run = function(index, next) {\n\t        return next.doDrop({\n\t          message: options.dropErrorMessage\n\t        });\n\t      }, this._drainOne = () => {\n\t        return this.Promise.resolve(null);\n\t      }, this._registerLock.schedule(() => {\n\t        return this._submitLock.schedule(() => {\n\t          var k, ref, v;\n\t          ref = this._scheduled;\n\t          for (k in ref) {\n\t            v = ref[k];\n\t            if (this.jobStatus(v.job.options.id) === \"RUNNING\") {\n\t              clearTimeout(v.timeout);\n\t              clearTimeout(v.expiration);\n\t              v.job.doDrop({\n\t                message: options.dropErrorMessage\n\t              });\n\t            }\n\t          }\n\t          this._dropAllQueued(options.dropErrorMessage);\n\t          return waitForExecuting(0);\n\t        });\n\t      })) : this.schedule({\n\t        priority: NUM_PRIORITIES$1 - 1,\n\t        weight: 0\n\t      }, () => {\n\t        return waitForExecuting(1);\n\t      });\n\t      this._receive = function(job) {\n\t        return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));\n\t      };\n\t      this.stop = () => {\n\t        return this.Promise.reject(new Bottleneck.prototype.BottleneckError(\"stop() has already been called\"));\n\t      };\n\t      return done;\n\t    }\n\n\t    async _addToQueue(job) {\n\t      var args, blocked, error, options, reachedHWM, shifted, strategy;\n\t      ({args, options} = job);\n\t      try {\n\t        ({reachedHWM, blocked, strategy} = (await this._store.__submit__(this.queued(), options.weight)));\n\t      } catch (error1) {\n\t        error = error1;\n\t        this.Events.trigger(\"debug\", `Could not queue ${options.id}`, {args, options, error});\n\t        job.doDrop({error});\n\t        return false;\n\t      }\n\t      if (blocked) {\n\t        job.doDrop();\n\t        return true;\n\t      } else if (reachedHWM) {\n\t        shifted = strategy === Bottleneck.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;\n\t        if (shifted != null) {\n\t          shifted.doDrop();\n\t        }\n\t        if ((shifted == null) || strategy === Bottleneck.prototype.strategy.OVERFLOW) {\n\t          if (shifted == null) {\n\t            job.doDrop();\n\t          }\n\t          return reachedHWM;\n\t        }\n\t      }\n\t      job.doQueue(reachedHWM, blocked);\n\t      this._queues.push(job);\n\t      await this._drainAll();\n\t      return reachedHWM;\n\t    }\n\n\t    _receive(job) {\n\t      if (this._states.jobStatus(job.options.id) != null) {\n\t        job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));\n\t        return false;\n\t      } else {\n\t        job.doReceive();\n\t        return this._submitLock.schedule(this._addToQueue, job);\n\t      }\n\t    }\n\n\t    submit(...args) {\n\t      var cb, fn, job, options, ref, ref1, task;\n\t      if (typeof args[0] === \"function\") {\n\t        ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);\n\t        options = parser$5.load({}, this.jobDefaults);\n\t      } else {\n\t        ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);\n\t        options = parser$5.load(options, this.jobDefaults);\n\t      }\n\t      task = (...args) => {\n\t        return new this.Promise(function(resolve, reject) {\n\t          return fn(...args, function(...args) {\n\t            return (args[0] != null ? reject : resolve)(args);\n\t          });\n\t        });\n\t      };\n\t      job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n\t      job.promise.then(function(args) {\n\t        return typeof cb === \"function\" ? cb(...args) : void 0;\n\t      }).catch(function(args) {\n\t        if (Array.isArray(args)) {\n\t          return typeof cb === \"function\" ? cb(...args) : void 0;\n\t        } else {\n\t          return typeof cb === \"function\" ? cb(args) : void 0;\n\t        }\n\t      });\n\t      return this._receive(job);\n\t    }\n\n\t    schedule(...args) {\n\t      var job, options, task;\n\t      if (typeof args[0] === \"function\") {\n\t        [task, ...args] = args;\n\t        options = {};\n\t      } else {\n\t        [options, task, ...args] = args;\n\t      }\n\t      job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\n\t      this._receive(job);\n\t      return job.promise;\n\t    }\n\n\t    wrap(fn) {\n\t      var schedule, wrapped;\n\t      schedule = this.schedule.bind(this);\n\t      wrapped = function(...args) {\n\t        return schedule(fn.bind(this), ...args);\n\t      };\n\t      wrapped.withOptions = function(options, ...args) {\n\t        return schedule(options, fn, ...args);\n\t      };\n\t      return wrapped;\n\t    }\n\n\t    async updateSettings(options = {}) {\n\t      await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));\n\t      parser$5.overwrite(options, this.instanceDefaults, this);\n\t      return this;\n\t    }\n\n\t    currentReservoir() {\n\t      return this._store.__currentReservoir__();\n\t    }\n\n\t    incrementReservoir(incr = 0) {\n\t      return this._store.__incrementReservoir__(incr);\n\t    }\n\n\t  }\n\t  Bottleneck.default = Bottleneck;\n\n\t  Bottleneck.Events = Events$4;\n\n\t  Bottleneck.version = Bottleneck.prototype.version = require$$8.version;\n\n\t  Bottleneck.strategy = Bottleneck.prototype.strategy = {\n\t    LEAK: 1,\n\t    OVERFLOW: 2,\n\t    OVERFLOW_PRIORITY: 4,\n\t    BLOCK: 3\n\t  };\n\n\t  Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = BottleneckError_1;\n\n\t  Bottleneck.Group = Bottleneck.prototype.Group = Group_1;\n\n\t  Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require$$2;\n\n\t  Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require$$3;\n\n\t  Bottleneck.Batcher = Bottleneck.prototype.Batcher = Batcher_1;\n\n\t  Bottleneck.prototype.jobDefaults = {\n\t    priority: DEFAULT_PRIORITY$1,\n\t    weight: 1,\n\t    expiration: null,\n\t    id: \"<no-id>\"\n\t  };\n\n\t  Bottleneck.prototype.storeDefaults = {\n\t    maxConcurrent: null,\n\t    minTime: 0,\n\t    highWater: null,\n\t    strategy: Bottleneck.prototype.strategy.LEAK,\n\t    penalty: null,\n\t    reservoir: null,\n\t    reservoirRefreshInterval: null,\n\t    reservoirRefreshAmount: null,\n\t    reservoirIncreaseInterval: null,\n\t    reservoirIncreaseAmount: null,\n\t    reservoirIncreaseMaximum: null\n\t  };\n\n\t  Bottleneck.prototype.localStoreDefaults = {\n\t    Promise: Promise,\n\t    timeout: null,\n\t    heartbeatInterval: 250\n\t  };\n\n\t  Bottleneck.prototype.redisStoreDefaults = {\n\t    Promise: Promise,\n\t    timeout: null,\n\t    heartbeatInterval: 5000,\n\t    clientTimeout: 10000,\n\t    Redis: null,\n\t    clientOptions: {},\n\t    clusterNodes: null,\n\t    clearDatastore: false,\n\t    connection: null\n\t  };\n\n\t  Bottleneck.prototype.instanceDefaults = {\n\t    datastore: \"local\",\n\t    connection: null,\n\t    id: \"<no-id>\",\n\t    rejectOnDrop: true,\n\t    trackDoneStatus: false,\n\t    Promise: Promise\n\t  };\n\n\t  Bottleneck.prototype.stopDefaults = {\n\t    enqueueErrorMessage: \"This limiter has been stopped and cannot accept new jobs.\",\n\t    dropWaitingJobs: true,\n\t    dropErrorMessage: \"This limiter has been stopped.\"\n\t  };\n\n\t  return Bottleneck;\n\n\t}).call(commonjsGlobal);\n\n\tvar Bottleneck_1 = Bottleneck;\n\n\tvar lib = Bottleneck_1;\n\n\treturn lib;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}