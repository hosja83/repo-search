{"ast":null,"code":"function t(t, n, r, e, i, a, o) {\n  try {\n    var u = t[a](o),\n        c = u.value;\n  } catch (t) {\n    return void r(t);\n  }\n\n  u.done ? n(c) : Promise.resolve(c).then(e, i);\n}\n\nfunction n(n) {\n  return function () {\n    var r = this,\n        e = arguments;\n    return new Promise(function (i, a) {\n      var o = n.apply(r, e);\n\n      function u(n) {\n        t(o, i, a, u, c, \"next\", n);\n      }\n\n      function c(n) {\n        t(o, i, a, u, c, \"throw\", n);\n      }\n\n      u(void 0);\n    });\n  };\n}\n\nfunction r(t) {\n  for (var n = new ArrayBuffer(t.length), r = new Uint8Array(n), e = 0, i = t.length; e < i; e++) r[e] = t.charCodeAt(e);\n\n  return n;\n}\n\nfunction e(t) {\n  return t.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction i(t) {\n  return e(btoa(JSON.stringify(t)));\n}\n\nvar a = function () {\n  var t = n(function* (t) {\n    var {\n      privateKey: n,\n      payload: a\n    } = t;\n    if (/BEGIN RSA PRIVATE KEY/.test(n)) throw new Error(\"[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#readme\");\n\n    var o,\n        u = {\n      name: \"RSASSA-PKCS1-v1_5\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    },\n        c = (o = n.trim().split(\"\\n\").slice(1, -1).join(\"\"), r(atob(o))),\n        p = yield crypto.subtle.importKey(\"pkcs8\", c, u, !1, [\"sign\"]),\n        f = function (t, n) {\n      return \"\".concat(i(t), \".\").concat(i(n));\n    }({\n      alg: \"RS256\",\n      typ: \"JWT\"\n    }, a),\n        l = r(f),\n        s = function (t) {\n      for (var n = \"\", r = new Uint8Array(t), i = r.byteLength, a = 0; a < i; a++) n += String.fromCharCode(r[a]);\n\n      return e(btoa(n));\n    }(yield crypto.subtle.sign(u.name, p, l));\n\n    return \"\".concat(f, \".\").concat(s);\n  });\n  return function (n) {\n    return t.apply(this, arguments);\n  };\n}();\n\nfunction o(t) {\n  return u.apply(this, arguments);\n}\n\nfunction u() {\n  return (u = n(function* (t) {\n    var {\n      id: n,\n      privateKey: r,\n      now: e = Math.floor(Date.now() / 1e3)\n    } = t,\n        i = e - 30,\n        o = i + 600,\n        u = {\n      iat: i,\n      exp: o,\n      iss: n\n    };\n    return {\n      appId: n,\n      expiration: o,\n      token: yield a({\n        privateKey: r,\n        payload: u\n      })\n    };\n  })).apply(this, arguments);\n}\n\nexport { o as githubAppJwt };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO;;AAAA,SAASA,CAAT,CAA4BC,CAA5B,EAA4BA;EAAAA,SACzBC,IAAM,IAAIC,WAAJ,CAAgBF,EAAIG,MAApB,CADmBH,EAEzBI,IAAU,IAAIC,UAAJ,CAAeJ,CAAf,CAFeD,EAGtBM,IAAI,CAHkBN,EAGfO,IAASP,EAAIG,MAHEH,EAGMM,IAAIC,CAHVP,EAGkBM,GAHlBN,EAI3BI,EAAQE,CAARF,IAAaJ,EAAIQ,UAAJR,CAAeM,CAAfN,CAAbI;;EAA4BE,OAEzBL,CAFyBK;AAyBpC;;AAAA,SAASG,CAAT,CAAoBC,CAApB,EAAoBA;EAAAA,OACTA,EACFC,OADED,CACM,IADNA,EACY,EADZA,EAEFC,OAFED,CAEM,KAFNA,EAEa,GAFbA,EAGFC,OAHED,CAGM,KAHNA,EAGa,GAHbA,CADSA;AAMpB;;AAAA,SAASE,CAAT,CAA0BC,CAA1B,EAA0BA;EAAAA,OACfJ,EAAWK,KAAKC,KAAKC,SAALD,CAAeF,CAAfE,CAALD,CAAXL,CADeI;AACgBA;;AAAAA;EAAAA;IAAAA;MAAAA;MAAAA;IAAAA;IAAAA;;IAAAA,IA3BhCI,CA2BgCJ;IAAAA,IA3BhCI;MAAAA;MAAAA;QAAAA;MAAAA;IAAAA,CA2BgCJ;IAAAA,IA3BhCI,WACDC,IADCD,GAEDE,KAFCF,CAEK,IAFLA,EAGDG,KAHCH,CAGK,CAHLA,EAGK,CAAI,CAHTA,EAIDI,IAJCJ,CAII,EAJJA,GAMClB,EADSuB,KAAKL,CAALK,CACTvB,CANDkB,CA2BgCJ;IAAAA,IAtBjBI,8DAsBiBJ;IAAAA,IAtBjBI,IAGlB,UAA2BM,CAA3B,EAAmCC,CAAnC,EAAmCA;MAAAA,iBAC5BZ,EAAiBW,CAAjBX,CAD4BY,EACXD,GADWC,EACXD,MADWC,CACAZ,EAAiBY,CAAjBZ,CADAY;IACiBA,CADpD,CACoDA;MAAAA;MAAAA;IAAAA,CADpD,EACoDA,CADpD,CAmBmCX;IAAAA,IAlBiBW,QAkBjBX;IAAAA,IAlBiBW,IAEpD,UAAsBC,CAAtB,EAAsBA;MAAAA,SACrBC,IAAS,EADYD,EAErBE,IAAQ,IAAItB,UAAJ,CAAeoB,CAAf,CAFaA,EAGrBG,IAAMD,EAAME,UAHSJ,EAIhBnB,IAAI,CAJYmB,EAITnB,IAAIsB,CAJKH,EAIAnB,GAJAmB,EAKrBC,KAAUI,OAAOC,YAAPD,CAAoBH,EAAMrB,CAANqB,CAApBG,CAAVJ;;MAAoCpB,OAEjCG,EAAWK,KAAKY,CAALZ,CAAXL,CAFiCH;IAEjBoB,CAPpB,CAOoBA,sCAPpB,CAgBmCb;;IATfa;EAAAA,CASeb;EATfa;IAAAA;EAAAA;AAAAA,CASeb;;AATfa;EAAAA;AAAAA;;AAAAA;EAAAA;IAAAA;MAAAA;MAAAA;MAAAA;IAAAA;IAAAA;IAAAA;IAAAA;MAAAA;MAAAA;MAAAA;IAAAA;IAAAA;MAAAA;MAAAA;MAAAA;QAAAA;QAAAA;MAAAA;IAAAA;EAAAA;AAAAA;;AAAAA","names":["string2ArrayBuffer","str","buf","ArrayBuffer","length","bufView","Uint8Array","i","strLen","charCodeAt","fromBase64","base64","replace","base64encodeJSON","obj","btoa","JSON","stringify","pemB64","trim","split","slice","join","atob","header","payload","buffer","binary","bytes","len","byteLength","String","fromCharCode"],"sources":["/home/hosainy/documents/oden-project/repos/sas-interview-assignment/node_modules/universal-github-app-jwt/dist-web/index.js"],"sourcesContent":["function string2ArrayBuffer(str) {\n    const buf = new ArrayBuffer(str.length);\n    const bufView = new Uint8Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\nfunction getDERfromPEM(pem) {\n    const pemB64 = pem\n        .trim()\n        .split(\"\\n\")\n        .slice(1, -1) // Remove the --- BEGIN / END PRIVATE KEY ---\n        .join(\"\");\n    const decoded = atob(pemB64);\n    return string2ArrayBuffer(decoded);\n}\nfunction getEncodedMessage(header, payload) {\n    return `${base64encodeJSON(header)}.${base64encodeJSON(payload)}`;\n}\nfunction base64encode(buffer) {\n    var binary = \"\";\n    var bytes = new Uint8Array(buffer);\n    var len = bytes.byteLength;\n    for (var i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return fromBase64(btoa(binary));\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction base64encodeJSON(obj) {\n    return fromBase64(btoa(JSON.stringify(obj)));\n}\n\nconst getToken = async ({ privateKey, payload }) => {\n    // WebCrypto only supports PKCS#8, unfortunately\n    if (/BEGIN RSA PRIVATE KEY/.test(privateKey)) {\n        throw new Error(\"[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#readme\");\n    }\n    const algorithm = {\n        name: \"RSASSA-PKCS1-v1_5\",\n        hash: { name: \"SHA-256\" }\n    };\n    const header = { alg: \"RS256\", typ: \"JWT\" };\n    const privateKeyDER = getDERfromPEM(privateKey);\n    const importedKey = await crypto.subtle.importKey(\"pkcs8\", privateKeyDER, algorithm, false, [\"sign\"]);\n    const encodedMessage = getEncodedMessage(header, payload);\n    const encodedMessageArrBuf = string2ArrayBuffer(encodedMessage);\n    const signatureArrBuf = await crypto.subtle.sign(algorithm.name, importedKey, encodedMessageArrBuf);\n    const encodedSignature = base64encode(signatureArrBuf);\n    return `${encodedMessage}.${encodedSignature}`;\n};\n\nasync function githubAppJwt({ id, privateKey, now = Math.floor(Date.now() / 1000), }) {\n    // When creating a JSON Web Token, it sets the \"issued at time\" (iat) to 30s\n    // in the past as we have seen people running situations where the GitHub API\n    // claimed the iat would be in future. It turned out the clocks on the\n    // different machine were not in sync.\n    const nowWithSafetyMargin = now - 30;\n    const expiration = nowWithSafetyMargin + 60 * 10; // JWT expiration time (10 minute maximum)\n    const payload = {\n        iat: nowWithSafetyMargin,\n        exp: expiration,\n        iss: id\n    };\n    const token = await getToken({\n        privateKey,\n        payload\n    });\n    return {\n        appId: id,\n        expiration,\n        token\n    };\n}\n\nexport { githubAppJwt };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}